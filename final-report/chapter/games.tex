\chapter{Boolean circuit puzzles and games}
\label{ch:circuit}

In this chapter, we begin to explore landscape of puzzle-and-game complexity
classes---specifically, the \emph{polynomial hierarchy}---through a series of
games played on boolean circuits.

\section{The \Problem{Circuit Value} problem, and \texorpdfstring{\(\ComplexityClass{P}\)}{ùêè}}

To set the stage, we start with a relatively ``easy'' problem, known as the
\Problem{Circuit Value} problem, or \Problem{CircVal} for short:

%\begin{definition}{\(\Problem{Circuit Value}=\Problem{CircVal}\)}{}
%
%  Let \(C\) be a given boolean circuit with all input wires/variables
%  specified. What is the final output value of \(C\)? As a decision problem:
%  \(C‚àà\Problem{Circuit Value}\) if it outputs \True, and \(C‚àâ\Problem{Circuit
%  Value}\) if it outputs \False.
%
%\end{definition}

\begin{problem}[lefthand ratio=.5]{\Problem{Circuit Value} / \CircVal}{circ-val}
  \begin{description}[nosep]
    \item[Given:] a boolean circuit with all inputs specified
    \item[Return whether:] the circuit outputs \True
  \end{description}
  %

  %Given a boolean circuit with all inputs specified, compute its output. Return
  %\emph{yes} if the output is \True.
%
%  \tcblower
%  \CircVal = \SetBuilder{\text{circuit \(C\)}}{C()=\True}
\end{problem}

It is well-known that \(\CircVal‚àà\P\) (i.e., it is actually ``easy'').  We give
one version of a proof below.

\begin{theorem}{\(\CircVal‚àà\P\)}{}

  \CircVal{} is solvable in polynomial time.

\end{theorem}

\begin{proof}
  We give a polynomial-time algorithm solving \Problem{Circuit Value} below.
  (Note that this is not the most efficient algorithm doing so; we choose it
  here only for its simplicity.)

  \begin{algorithm}{a polynomial-time \CircVal{} solver}{}
    \begin{algorithmic}
      \Given{\(C\), a boolean circuit with all inputs fully specified}
      \LComment{Call a wire \emph{finished} if it has been assigned a boolean
        value. Initially, all the input wires are finished, since their values
      were given, and all intermediate and output wires are unfinished.}%
      \While{final output wire is not finished}%
      \ForEach{unfinished logic gate \(g\) in \(C\)}%
      \If{all input wires of \(g\) are finished}%
      \State{compute and assign the output value of \(g\) to its output wire}%
      \EndIf%
      \EndFor%
      \EndWhile%
      \State \Return value assigned to final output wire%
    \end{algorithmic}
  \end{algorithm}

  We argue that this algorithm terminates in polynomial time.  On each
  iteration of the ``while'' loop, at least one logic gate is guaranteed to
  have all of its inputs done, since there are no cyclic dependencies in the
  circuit.  Thus each iteration of the ``while'' loop finishes at least one
  additional wire.  Therefore, the number of ``while'' iterations is at most
  the number of wires in the circuit, and the work done within each iteration
  is also polynomial with respect to the size of the circuit, so the overall
  algorithm terminates in polynomial time.
\end{proof}

To kickstart the puzzles-and-games perspective, we think of \Problem{Circuit
Value}---and actually, every problem in \P---as a game with \(0\) turns: the
player does nothing, and an (efficient) algorithm automatically decides whether
the player wins or loses.

This seems like a silly (arguably boring) idea.  But, as we see in the next few
sections, this approach allows us to generalize \Problem{Circuit Value} into
very powerful puzzles and games.

\section{The \Problem{Circuit Satisfiability} puzzle, and \NP}

By \emph{puzzle}, we really mean \(1\)-turn games: games in which a player
makes a sequence of ``moves'' on a given ``game board'', and an (efficient)
algorithm then determines whether the player's moves constitute a win.
Formulated as decision problems, the computational puzzle is the yes/no
question:
\begin{center}
  Does the player have a winning strategy?
\end{center}

For example, consider a puzzle-ification of \Problem{CircVal}, where the
circuit's inputs are no longer specified but rather chosen by the player (this
is the ``move'' made by the player).  Recall that the player wins if the
circuit's output is \True.  Thus, when we allow the player to choose inputs, a
winning strategy means a combination of inputs causing the circuit to output
\True.  The decision problem asking whether such a winning move exists is
called \Problem{Circuit Satisfiability}, or \Problem{CircSat} for short:

%\begin{definition}{\(\Problem{Circuit Satisfiability}=\Problem{CircSat}\)}{}
%
%  Let \(C\), a boolean circuit, be given. Does there exist a combination of
%  boolean input values to \(C\) causing it to output \True?
%
%\end{definition}

\begin{problem}{\Problem{Circuit Satisfiability} / \CircSat}{circsat}

  Given a boolean circuit \(C\), determine whether there exists some assignment
  to its inputs causing its output to be set to \True.  Such an assignment is
  called a \Term{satisfying assignment of \(C\)}.
%
%  \tcblower
%  \CircSat = \SetBuilder{\text{circuit \(C\) with \(n\) inputs}}{‚àÉX‚àà\TF[n]\Q C(X)=\True}
\end{problem}

Briefly: how (computationally) difficult is \Problem{CircSat}?  As it turns
out, nobody knows for sure, but it seems \emph{quite} difficult.  Loosely
speaking, all known algorithms for solving \Problem{CircSat} amount to brute
force with optimizations that enhance performance on ``practical'', real-world
inputs but do not save them from performing poorly in the worst case.
Tentatively, then, most computer scientists suspect that
\(\Problem{CircSat}‚àâ\P\)---i.e., there is no polynomial-time solution for
\Problem{CircSat}.

TODO: here's a survey to cite on on pnp opinion:
\url{https://dl.acm.org/doi/10.1145/564585.564599}.  cite it correctly later.
% https://www.researchgate.net/publication/292393040_The_PNP_poll

% TODO maybe cite an up-to-date result about how good the bound is, but whatever

% useful citation about best-known SAT bounds: https://cstheory.stackexchange.com/questions/1060/best-upper-bounds-on-sat

% https://www.sciencedirect.com/science/article/pii/S0304397501001748?via%3Dihub
% 3sat solvable in 1.5^n?



Anyway, back to puzzles.  \Problem{CircSat} is one example of how a \(0\)-turn
game such as \Problem{CircVal} may be generalized into a \(1\)-turn game---a
puzzle.  How can we do this in general, for arbitrary games?

In the example of \Problem{CircSat}, we do this by making the player supplement
the input to the the \(0\)-turn analog, \Problem{CircVal}.  This approach is
readily generalized.  Given some input \(X\) (the ``game board''), construct a
\(1\)-turn game in which the player specifies a supplementary input \(Y\);
victory is decided by whether the pair of inputs \((X,Y)\) meets the \(0\)-turn
winning condition, which should be an efficiently-computable condition---a
problem in \P.  As before, the decision problem asks whether the player can win:
does there exist \(Y\) such that \((X,Y)\) meets the winning condition?

The complexity class of all \(1\)-turn game problems constructed in this manner
is called \NP.  Before we give the formal definition of \NP, we need to
introduce one more technical detail.  In the discussion above, call \(Œ†\) the
\(0\)-turn winning condition problem.  We said above that \(Œ†\) should be
computable in polynomial-time.  More precisely, we want it to be computable in
polynomial-time with respect to the size of the \emph{game board} \(X\).
However, the input string to the \(Œ†\) isn't just \(X\) but the pair \((X,Y)\),
so simply requiring \(Œ†‚àà\P\) is insufficient: polynomial with respect to the
size of \((X,Y)\) does not imply polynomial with respect to the size of \(X\)
(\(Y\) could be arbitrarily long).  To fix this disparity, we additionally
require that the player's input scales controlledly with the game board: the
size of \(Y\) must be polynomially-bounded by the size of \(X\).

%This requirement guarantees that
%\(Y\) does not unduly distort the input size, and any polynomial function on the
%size of \((X,Y)\) is also polynomial with respect to the size of \(X\).  We call
%problems with this constraint \emph{polynomially balanced}.
%
%\begin{definition}{polynomially balanced}{balance}
%
%  Let \(Œ†‚äÜ\Set{0,1}^*√ó\Set{0,1}^*\) be a decision problem whose inputs are
%  \emph{pairs} of strings.  We say \(Œ†\) is \Term{polynomially balanced} if
%  there exists a polynomial function \(p\) such that, for every \((X,Y)‚ààŒ†\),
%  \[
%    \Abs Y‚â§p(\Abs X).
%  \]
%
%\end{definition}

We are now ready to give the full definition of \NP{} (the class of all
\(1\)-turn games).

\begin{definition}{\NP}{np}

  \NP{} is the class of decision problems \(Œ†\) such that
  \begin{nest}
    there exists a \(Œ†'‚àà\P\) (the \(0\)-turn winning condition) and a polynomial
    \(p\) such that
    \begin{nest}
      for each input \(X‚àà\Strings\) (the game board)
      \begin{nest}
        \(X‚ààŒ†\) (the player can guarantee a win) if and only if
        \begin{nest}
          there exists \(Y‚àà\Strings\) (the player's move) such that \(\Abs
          Y‚â§p(\Abs X)\), and
          \begin{nest}
            \((X,Y)‚ààŒ†'\) (the move meets the winning condition).
          \end{nest}
        \end{nest}
      \end{nest}
    \end{nest}
  \end{nest}

\end{definition}

Notice the inductive relationship between \P{} and \NP.  Each problem \(Œ†‚àà\NP\)
is constructed by \emph{adding one turn} to some other problem \(Œ†'‚àà\P\).

Unsurprisingly, \CircSat{} is in \NP{} (after all, we used it as the example
problem to motivate the general definition of \NP).  To demonstrate this
inclusion formally, we show how the definition of \CircSat{} fits the definition
of \NP.

\begin{theorem}{}{}
  \(\CircSat‚àà\NP\).
\end{theorem}

\begin{proof}

  Let \(Œ†'=\CircVal\).  Specifically, think of \(Œ†'\) as a set of \emph{pairs}
  \((C,X)\) where \(C\) specifies the boolean circuit, and \(X\) specifies a
  input assignment to \(C\) so that \(C(X)=\True\).  The length of \(X\) always
  matches the number of input variables in \(C\), which by definition is
  polynomially bounded by the size of \(C\).

  \CircSat{} comprises exactly the set of circuits \(C\) (the game board) for
  which there exists an \(X\) (the player's move) such that
  \((C,X)‚ààŒ†'=\CircVal\).  Thus \CircSat{} fits the definition of an \NP{}
  problem.  \qedhere

\end{proof}

%Now, given a \CircSat{} instance---namely, a circuit \(C\) with \(n\)
%unspecified inputs---the player's move \(X‚àà\TF[n]\) augments \(C\) to form a
%new circuit \(C'=C[X]\) with \emph{no} unspecified inputs.  The player wins if
%and only if \(C'\) outputs \True; that is, if \(C'‚àà\CircVal\).
%\[
%  \CircSat=\SetBuilder{
%    \text{circuit \(C\) with \(n\) inputs}
%  }{
%    ‚àÉX‚àà\Set{\True,\False}‚Åø\Q C[X]‚àà\CircVal
%  }.
%\]
%This inductive formulation of \CircSat{} shows clearly that \(\CircSat‚àà\NP\).
%We will also see later that the add-a-turn extension shown here can be
%generalized to construct games with many turns.

% see later in section TODO

% i wonder whether i should define projections here


%If
%\(Œ†\) asks the question,
%\begin{nest}
%  Does the first player have a winning strategy in a game of \(k\) turns?
%\end{nest}
%That question is answered by asking, in turn,
%\begin{nest}
%  After the first turn has been played, is the first player the guaranteed
%  winner
%\end{nest}



\subsection{\Problem{CircSat} is \NP-complete}

%We can also think of problems in \NP, or puzzles, as problems solvable by
%guess-and-check: guess a move \(Y\), and check whether it meets the winning
%condition.

What makes \CircSat{} especially interesting, compared to all the other puzzles
in \NP, is that \CircSat{} is \NP-\emph{complete}.  In other words, \CircSat{}
is the hardest of the \NP{} puzzles: any other \NP{} problem reduces to
\CircSat. This result is known as the Cook--Levin theorem:

\begin{theorem}{Cook--Levin}{cook-levin}

  \CircSat{} is \NP-complete.

\end{theorem}

A full proof of the Cook--Levin theorem would require delving into formal
technicalities about Turing Machines, which is beyond the scope of this thesis.
Instead, we give here some informal intuition about the basic idea underlying
the proof and why the Cook--Levin result makes sense.

As mentioned in \cref{ch:boolean}, any computer can be expressed in terms of
boolean circuits; in fact, modern computers literally are implemented using
boolean circuits. Therefore, the execution of any algorithm \(A\) is just a
sequence of circuit computations, one for each time-step of the algorithm. Thus
every \(1\)-turn game is really just a \emph{special case} of the
\Problem{Circuit Satisfiability} problem.

%\subsection{\True{} or \False?}
%
%In our definition of \CircSat, we say the player wins if the output of the
%circuit is set to \True.  But there is nothing special about \True---we could
%have defined the puzzle so that the player wins if the circuit outputs \False;
%the two formulations are exactly equivalent in difficulty.  Call the
%win-if-\False{} version of the puzzle \Problem{Circuit Falsifiability}:
%
%\begin{problem}{\Problem{Circuit Falsifiability}}{}
%
%  Given a boolean circuit \(C\), determine whether there exists some assignment
%  to its inputs causing its output to be set to \False.  Such an assignment is
%  called a \Term{falsifying assignment of \(C\)}.
%
%  \tcblower
%  \Problem{Circuit Falsifiability}=\SetBuilder{\text{circuit \(C\) with \(n\) inputs}}{
%    ‚àÉX‚àà\TF[n]\Q C(X)=\False
%  }
%\end{problem}
%
%Note that \Problem{Circuit Falsifiability} is not the same as the
%\emph{complement} of \Problem{Circuit Satisfiability}, whose answer is ``yes''
%when the player's moves \emph{always} lead to a \False{} output:
%\begin{align*}
%  \Problem{Circuit Satisfiability} &= \SetBuilder{C}{‚àÉX\ldotp C(X)=\True} \\
%  (\Problem{Circuit Satisfiability})\Complement &= \SetBuilder{C}{‚àÑX\ldotp C(X)=\True}
%  = \SetBuilder{C}{‚àÄX\ldotp C(X)=\False} \\
%  \Problem{Circuit Falsifiability} &= \SetBuilder{C}{‚àÉX\ldotp C(X)=\False}.
%\end{align*}
%
%To see that this formulation is equivalent in difficulty to \Problem{Circuit
%Satisfiability}, we show that both problems reduce to each other.
%
%\begin{theorem}{}{}
%
%  \Problem{Circuit Satisfiability} and \Problem{Circuit Falsifiability} are
%  equivalent in difficulty.
%
%\end{theorem}
%
%\begin{proof}
%
%  Let any circuit \(C\) be given.  Compose its output with a \NOT{} gate,
%  forming a new circuit \(¬¨C\) whose output is always opposite that of \(C\).
%
%  Therefore, \(C\) is satisfiable if and only if \(¬¨C\) is falsifiable;
%  conversely, \(C\) is falsifiable if and only if \(¬¨C\) is satisfiable.  Thus
%  the compose-with-\NOT-gate transformation is a reduction going both ways:
%  \begin{align*}
%    \Problem{Circuit Falsifiability} &‚â§ \Problem{Circuit Satisfiability}, \\
%    \Problem{Circuit Satisfiability} &‚â§ \Problem{Circuit Falsifiability}.
%    \qedhere
%  \end{align*}
%
%\end{proof}
%
%
%
%A corollary of this result is that \Problem{Circuit Falsifiability} is also
%\NP-complete and therefore fully ``characterizes'' \NP.
%
%\[
%  \Problem{Circuit Falsifiability} =
%  \SetBuilder{\text{circuit \(C\) with \(n\) inputs}}{¬¨C‚àà\CircSat}.
%\]
%
%TODO think about reframing this


%A corollary-corollary,
%then, is that \(\co\Problem{Circuit Falsifiability}\) is \(\co\NP\)-complete.
%We leverage this result in the next section, where we introduce a second player
%whose goal is, indeed, to \emph{falsify} the circuit.

\section{Two-player circuit games, and the polynomial hierarchy}

Recall, in the \(1\)-turn game \CircSat, a single player assigns inputs to a
given circuit, with the goal of getting the circuit to output \True.  Now, we
introduce a second player, an \emph{antagonist}, working towards the opposite
goal.  The two players now take turns assigning inputs in the circuit; when all
inputs have been assigned, the circuit's final output dictates the winner
(\(\True‚üπ\text{first player wins}\), \(\False‚üπ\text{second player wins}\)).
Now, framing this game as a decision problem, we ask the yes/no question,
\begin{center}
  Does the \emph{first} player have a winning strategy?
\end{center}

To start with a concrete example, consider the version of this game with \(2\)
turns.  A circuit \(C\) is given; its (unassigned) inputs are partitioned into
two groups, \(I‚ÇÅ\) and \(I‚ÇÇ\).  Two turns proceed: the first player assigns
values to all inputs in \(I‚ÇÅ\), then the second player assigns values to all
inputs in \(I‚ÇÇ\).  Finally, if the circuit outputs \True, the first player
wins; otherwise, the second player wins.  Now, we ask, does the first player
have a winning strategy?

To be more precise, by \emph{winning strategy}, we mean a move the first player
can make in order to guarantee a win, no matter what the second player plays in
response.  In other words, if the first player plays a winning move, then there
\emph{does not exist} a counter-winning move by the second player.  Thus, in
this example, what we are actually asking is, does there exist \(X‚ÇÅ\) such that
there does not exist \(X‚ÇÇ\) setting \(C(X‚ÇÅ,X‚ÇÇ)=\False\)?  We call this decision
problem \(\CircSat‚ÇÇ\).

%\begin{definition}{\Problem{Circuit Satisfiability} with \(2\) turns, a.k.a.
%  \(\CircSat‚ÇÇ\)}{}
%
%  Let \(C\), a boolean circuit, be given, with its inputs partitioned into two
%  groups \(I‚ÇÅ\) and \(I‚ÇÇ\).  Does there exist some
%  \(X‚ÇÅ‚àà\Set{\True,\False}^{\Abs{I‚ÇÅ}}\) such that‚Ä¶
%  \begin{nest}
%    there does \emph{not} exist an
%    \(X‚ÇÇ‚àà\Set{\True,\False}^{\Abs{I‚ÇÇ}}\) such that‚Ä¶
%    \begin{nest}
%      \(C(I‚ÇÅ‚âîX‚ÇÅ,I‚ÇÇ‚âîX‚ÇÇ)=\False\)?
%    \end{nest}
%  \end{nest}
%
%\end{definition}

\begin{problem}[lefthand ratio=.5]{\Problem{Circuit Satisfiability} with \(2\) turns / \(\CircSat‚ÇÇ\)}{}

  \begin{description}
  \item[Given:] a boolean circuit \(C\), with inputs partitioned into two groups
    \(I‚ÇÅ,I‚ÇÇ\)

  \item[Determine whether:] there exists some \(X‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\) such that
    \begin{nest}
      there does \emph{not} exist any \(X‚ÇÇ‚àà\TF[\Abs{I‚ÇÇ}]\) such that
      \begin{nest}
        \(C(I‚ÇÅ‚âîX‚ÇÅ,I‚ÇÇ‚âîX‚ÇÇ)=\False\)
      \end{nest}
    \end{nest}
  \end{description}

  %\tcblower
  %\CircSat‚ÇÇ=\SetBuilderLong{\text{circuit \(C\) with inputs \(I‚ÇÅ‚äîI‚ÇÇ\)}}{
  %  ‚àÉX‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\Q
  %  ‚àÑX‚ÇÇ‚àà\TF[\Abs{I‚ÇÇ}]\Q
  %  C(I‚ÇÅ‚âîX‚ÇÅ,I‚ÇÇ‚âîX‚ÇÇ)=\False
  %}.
\end{problem}

Earlier, we observed that \(\CircSat\) could be thought of as an add-one-turn
extension of \CircVal.  Similarly, we can formulate \(\CircSat‚ÇÇ\) as such an
extension of \CircSat.

To help do so, let's first formalize what it means for a player to take a single
turn.  When the player makes an assignment to some inputs, we say the player
\emph{augments} the circuit, creating a new circuit in which those inputs are
fixed to the (constant) assigned values.

\begin{definition}{augmented circuit}{}

  Let \(C\) be a circuit, and let \(I\) refer to a subset of the inputs of
  \(C\).

  Let \(X‚àà\Set{\True,\False}^{\Abs I}\) be a boolean assignment to the inputs
  in \(I\).  We call the new circuit \(C'\) produced by fixing inputs \(I\) to
  values \(X\) an \Term{augmented circuit \(C'=C[I‚âîX]\)}.

  To simplify notation, if \(I\) comprises \emph{all} inputs of \(C\), then we
  simply denote \(C[I‚âîX]=C[X]\).

\end{definition}

Now, in the two-turn game \CircSat[2], we start with a circuit \(C\), whose
inputs are partitioned into \(I‚ÇÅ‚äîI‚ÇÇ\).  On the first turn, the first player
makes an assignment \(X‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\) to the inputs \(I‚ÇÅ\).  After that
assignment, the remaining circuit is the augmented circuit \(C'=C[I‚ÇÅ‚âîX‚ÇÅ]\),
whose inputs are just \(I‚ÇÇ\).  The first player's initial move is a winning move
if and only if \(C'\) is now \emph{unfalsifiable}---or, in other words, its
negation \(¬¨C'\) is unsatisfiable.
\[
  \CircSat‚ÇÇ = \SetBuilderLong{
    \text{circuit \(C\) with inputs \(I‚ÇÅ‚äîI‚ÇÇ\)}
  }{
    ‚àÉX‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\ldotp
    ¬¨C[I‚ÇÅ‚âîX‚ÇÅ]‚àâ\CircSat
  }.
\]

Continuing this process gives a general construction for \(k\)-turn circuit
games, in which the two players take turns assigning values to groups of inputs.
Start with a boolean circuit \(C\), with inputs partitioned into \(k\) groups,
\(I‚ÇÅ,I‚ÇÇ,\dotsc,I‚Çñ\).  On the \(i\)-th turn, the \((i\bmod2)\)-th player assigns
values to the inputs in \(I·µ¢\); the initial player wins if the final circuit
outputs \True.

We formulate this game inductively as follows.
\begin{itemize}
  \item In the base-case game with \(k=0\) turns, all inputs have been assigned
    values.  The winning condition is determined by whether the circuit's output
    is \True.  This is the \CircVal{} problem.
  \item For \(k‚â•1\), the game starts with a circuit \(C\) with inputs
    partitioned as \(I‚ÇÅ‚äîI‚ÇÇ‚äî\dotsb‚äîI‚Çñ\).

    On the first turn, the first player assigns values \(X‚àà\TF[\Abs{I‚ÇÅ}]\) to
    the inputs \(I‚ÇÅ\), resulting in the augmented circuit \(C[I‚ÇÅ‚âîX]\) with
    (unassigned) inputs now partitioned into \(k-1\) remaining groups,
    \(I‚ÇÇ‚äî\dotsb‚äîI‚Çñ\).

    Now, a \((k-1)\)-turn game is played, starting with the opposite player, on
    the \emph{negated circuit} \(C'=¬¨C[I‚ÇÅ‚âîX‚ÇÅ]\).  The negation ensures that the
    opposite player wins (satisfying \(C'‚â°¬¨C\)) exactly by falsifying \(C\).
    Thus the original first player wins if and only if \(C'\) is un-winnable for
    the second player.
\end{itemize}


%\begin{enumerate}[left=1.5em]
%  \item[{[\(1\)]}] On the first turn, the first player assigns values
%    \(X‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\) to the inputs \(I‚ÇÅ\).
%  \item[{[\(2\)--\(k\)]}] The remaining \(k-1\) turns proceed inductively.  It
%    is played on the augmented circuit \(C'=C[I‚ÇÅ‚âîX‚ÇÅ]\), whose inputs are
%    partitioned into \(k-1\) groups, \(I‚ÇÇ,\dotsc,I‚Çñ\), starting with the second
%    player's move.
%\end{enumerate}
%The first player's initial move is a winning move if and only if, in the
%remaining \((k-1)\)-turn game, the responding player does \emph{not} have a
%(counter-)winning strategy.  Finally, the first player wins if and only if the
%completed circuit (after all turns) passes \CircVal.

\begin{problem}{\Problem{Circuit Satisfiability} with \(k\) turns / \(\CircSat_k\)}{}

  For \(k=0\), define \(\CircSat‚ÇÄ=\CircVal\).  For \(k‚â•1\), define
  \(\CircSat[k]\) as follows:

  \tcblower

  \begin{description}[nosep]
    \item[Given:] a circuit with inputs partitioned into \(k\) groups,
      \((C,(I‚ÇÅ,\dotsc,I‚Çñ))\)
    \item[Determine whether:] there exists an \(X‚àà\TF[\Abs{I‚ÇÅ}]\) such that
      \begin{nest}
        \((¬¨C[I‚ÇÅ‚âîX],(I‚ÇÇ,\dotsc,I‚Çñ))‚àâ\CircSat[k-1]\)
      \end{nest}
    \end{description}

  \begin{aside}
    Also, observe that \(\CircSat[1]=\CircSat\).
  \end{aside}


  %Given a boolean circuit \(C\) with inputs partitioned into \(k\) groups
  %\(I‚ÇÅ,I‚ÇÇ,\dotsc,I‚Çñ\), determine whether the first player has a winning
  %strategy.

  %\tcblower
  %\CircSat‚ÇÄ &= \CircVal, \\
  %\CircSat‚ÇÅ &= \CircSat, \\
  %\CircSat_k &= \SetBuilderLong{
  %  \text{circuit \(C\) with inputs \(I‚ÇÅ‚äîI‚ÇÇ‚äî\dotsb‚äîI‚Çñ\)}
  %}{
  %  ‚àÉX‚ÇÅ‚àà\TF[\Abs{I‚ÇÅ}]\Q
  %  ¬¨C[I‚ÇÅ‚âîX‚ÇÅ]‚àâ\CircSat_{k-1}
  %}
\end{problem}

Finally, we can generalize this construction to arbitrary games beyond those
player on circuits.  Consider an arbitrary game of \(k\) turns, played on some
game board \(X‚àà\Strings\).  Two players take turns making moves
\(Y‚ÇÅ,Y‚ÇÇ,\dotsc,Y‚Çñ‚àà\Strings\).  At the end, an efficient algorithm determines
which player wins.  Stating this inductively:
\begin{itemize}
  \item \(0\)-turn games (winning conditions) are (see \cref{def:balance})
    problems in \P.
  \item \(k\)-turn games start with a game board \(X‚àà\Strings\).  The first
    player makes a move \(Y‚àà\Strings\), and then wins if and only if the
    ``augmented'' \((k-1)\)-turn game, \((X,Y)\), is a losing game for the
    opposite player.
\end{itemize}

%\begin{enumerate}
%  \item[{[\(1\)]}] On the first turn, the first player makes some move
%    \(M‚ÇÅ‚àà\TF[*]\).  whose size is bounded by some polynomial function of \(\Abs
%    B\) (thereby preventing the player's move from distorting the size of the
%    game; see the discussion at the end of \cref{def:np}).
%  \item[{[\(2\)--\(k\)]}] The remaining turns constitute a \((k-1)\)-turn game.
%    It is played on the ``augmented'' board \((B,M‚ÇÅ)\), starting now with the
%    second player.
%\end{enumerate}
%The first player's move is a winning move if and only if the responding player
%has \emph{no} winning strategy for the \((k-1)\)-turn game.  Finally, after all
%turns have been played (the base case), the \(0\)-turn game's winner is dictated
%by a winning condition checkable in polynomial time.  The decision problem asks
%whether the first player can guarantee a win.

For each \(k\), the complexity class of all such decision problems is called
\SigmaP k.  There are also the complements of problems in \(\SigmaP k\), which,
instead of asking whether the first player has a winning strategy, asks whether
the first player is \emph{doomed} to lose; the class of these decision problems
is called \(\PiP k=\co\SigmaP k\).

Together, \(\SigmaP k\)s and \(\PiP k\)s constitute the \emph{polynomial
hierarchy}.

\begin{definition}{polynomial hierarchy}{ph}

  \(\SigmaP0=\PiP0=\P=\co\P\) (\cref{cor:p-cop}) is the class of (efficient)
  \(0\)-turn game deciders.

  \(\SigmaP1=\NP\) is the class of \(1\)-turn game ``possible to win'' problems
  (given a \(1\)-turn board, return ``yes'' if the player has a winning move).
  \(\PiP1=\co\NP\) is the class of \(1\)-turn game, ``impossible to win''
  problems (given a \(1\)-turn board, return ``yes'' if the player has \emph{no}
  winning move).

  In general, for any \(k\), \(\SigmaP k\) is the class of \(k\)-turn
  ``possible to win'' problems, and \(\PiP k=\co\SigmaP k\) the class of
  \(k\)-turn ``impossible to win'' problems.

  Formally: let \(Œ†\) be any decision problem; we say \(Œ†\) is in \(\SigmaP k\)
  if
  \begin{nest}
    there exists a \(Œ†'‚àà\PiP{k-1}\) and a polynomial \(p\) such that
    \begin{nest}
      for each (game board) \(X‚àà\Strings[*]\)
      \begin{nest}
        \(X‚ààŒ†\) (is a winning game for the first player) if and only if
        \begin{nest}
          there exists an (initial move) \(Y‚àà\Strings[*]\) such that \(\Abs
          Y‚â§p(\Abs X)\), and
          \begin{nest}
            \((X,Y)‚ààŒ†'\) (the remaining game guarantees loss for the responding
            player).
          \end{nest}
        \end{nest}
      \end{nest}
    \end{nest}
  \end{nest}

\end{definition}

Notably, the circuit games \(\CircSat_k\) are \SigmaP k-complete for each
\(k\).

\begin{theorem}{}{}

  For each \(k=1,2,\dotsc\), \(\CircSat_k\) is \SigmaP k-complete.

\end{theorem}

Again, a full proof of this result is beyond the scope of this paper.
Essentially, this theorem holds for the same reason as the Cook--Levin theorem
(\cref{th:cook-levin}): all algorithms can be encoded as circuits, so all
problems are just special-cases of circuit problems.  For our purposes, we
take this theorem to be given.

In the next chapter, we will use this theorem as the central starting point for
exploring and ``benchmarking'' the complexities of other puzzles and games.


%completeness


%\[
%  \CircSat‚ÇÇ = \SetBuilder{\text{circuit \(C\)}}{
%    ‚àÉX‚ÇÅ\ldotp (C,X‚ÇÅ)‚àâ\Problem{Circuit Falsifiability}
%  }
%\]

