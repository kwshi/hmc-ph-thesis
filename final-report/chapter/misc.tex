\chapter{Graph 3-coloring games}
\label{ch:misc}

In the last chapter, we set the polynomial-hierarchy stage, focusing on circuit
games \(\CircSat‚Çñ\) as canonical examples of \SigmaP k-complete problems.  In
this chapter, we expand that landscape by exploring another collection \SigmaP
k-complete games, played via colorings on graph vertices.

It is only due to time constraints on this thesis that we stop at one game: I
hope to convey, through the examples presented in this chapter, the sense that
there are many, many \SigmaP k-complete games out there, all of which
intuitively stem from classic, well-known \NP-complete puzzles.

%\section{Graph coloring games}

\section{Preliminaries: graphs and proper colorings}

First, we introduce some preliminary definitions about graphs and colorings.  A
graph is a network of \emph{vertices} connected by \emph{edges}.  Formally:

\begin{definition}{(undirected) graphs}{}

  A \Term{graph} \(Œì\) is a pair \((\Vertices(Œì),\Edges(Œì))\) consisting of:
  \begin{itemize}[nosep]
    \item A finite set of \Term{vertices} \(\Vertices(Œì)\).
    \item A finite set of \Term{edges}
      \(\Edges(Œì)‚äÜ\SetBuilder{u‚Üîv}{u,v‚àà\Vertices(Œì)}\).  Visually, an edge is
      illustrated as a \emph{connection} between a pair of vertices.
  \end{itemize}

  For our purposes, edges have no directionality.  That is, when specifying an
  edge, the ordering of vertices doesn't matter: \(u‚Üîv\) is the same edge as
  \(v‚Üîu\).

  We say that two vertices \(u,v‚àà\Vertices(Œì)\) are \Term{adjacent}, or that
  they \Term{neighbor} each other, if \((u,v)‚àà\Edges(Œì)\).

\end{definition}

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}[scale=1.5]
      
      \coordinate[vertex](top);
      \coordinate[vertex](mouth) at (-1.3em,-.9em);
      \coordinate[vertex](chin) at (-.2em,-.7em);
      \coordinate[vertex](shoulder) at (1.7em,-5em);
      \coordinate[vertex](neck) at (2.3em,-4.5em);
      \coordinate[vertex](back) at (4.5em,-4.4em);
      \coordinate[vertex](tail) at (5.4em,-5.1em);
      \coordinate[vertex](leg1) at (1.5em,-9em);
      \coordinate[vertex](leg2) at (2.7em,-8.8em);
      \coordinate[vertex](leg3) at (4.3em,-9.1em);
      \coordinate[vertex](leg4) at (5.4em,-8.9em);

      \draw[edge]
      (top) .. controls +(-.4em,-.1em) and +(.5em,.3em) .. (mouth) 
      .. controls +(.4em,0) and +(-.3em,-.1em) .. (chin)
      .. controls +(.4em,-3.3em) and +(-.1em,6em) .. (leg1)
      (tail) .. controls +(-.3em,.4em) and +(.2em,-.1em) .. (back) 
      .. controls +(-.6em,.1em) and +(.7em,0em) .. (neck) 
      .. controls +(-2.1em,2.5em) and +(.6em,-.8em) .. (top)
      (chin) .. controls +(.4em,-2.2em) and +(-.2em,.8em) .. (shoulder)
      .. controls +(-.1em,-1em) and +(.2em,.9em) .. (leg1)
      (shoulder) .. controls +(.3em,-1.5em) and +(-.8em,1.5em) .. (leg2) 
      .. controls +(-.3em,1.6em) and +(0em,-2em) .. (neck)
      (back) .. controls +(.2em,-2.5em) and +(-.3em,1.5em) .. (leg4)
      .. controls +(0em,2.5em) and +(-.3em,-1.5em) .. (tail);

      \draw[edge, over]
      (leg1) .. controls +(.3em,.5em) and +(-.4em,-.2em) .. +(.7em,3.1em)
      .. controls +(1em,.5em) and +(-.2em,3.4em) .. (leg3)
      .. controls +(.3em,1.5em) and +(-1em,-.8em) .. (tail) 
      (shoulder) .. controls +(2em,.2em) and +(-1em,.2em) .. (tail);

      \draw[edge, over]
      (back) .. controls +(-.2em,-1.5em) and +(.1em,1em) .. (leg3);


    \end{tikzpicture}

    \caption{A giraph.}
  \end{center}
\end{figure}

% TODO example giraph (fun)

The graph coloring games we explore in this thesis are about assigning colors
to vertices on a graph.  We call such an assignment a \emph{vertex coloring}.
Specifically, for sake of simplicity, we restrict our attention to colorings
that involve only three colors.  The main rule constraining these color
assignments is that neighboring vertices must always be colored distinctly---we
call this the \emph{properness} condition.  These terms are defined precisely
below.

\begin{definition}{vertex 3-colorings, properness}{}%

  Let \(Œì\) be a graph. A \Term{vertex 3-coloring} of \(Œì\) is a map
  \(Œ∫\colon\Vertices(Œì)‚Üí\Colors\), which assigns to each vertex one of three
  colors.  In this thesis, we generally just say ``coloring'' to refer to
  ``vertex 3-colorings'', except when specified otherwise.

  A vertex coloring \(Œ∫\) is a \Term{proper} coloring if, for every edge
  \((u,v)‚àà\Edges(Œì)\), \(Œ∫(u)‚â†Œ∫(v)\)---i.e., no neighboring vertices share the
  same color.  To simplify discourse, we also call a particular
  edge/neighboring-pair \((u,v)‚àà\Edges(Œì)\) is \Term{proper} if \(Œ∫(u)‚â†Œ∫(v)\).
  Thus a proper coloring is one where all edges are proper; an improper
  coloring contains at least one improper edge.

\end{definition}

Having established the basic terminology, we now introduce the graph
(3-)coloring games.

\section{The \(0\)-turn game}

The goal of graph coloring games is to assign colors to all vertices so that
the resulting coloring is proper.  To this end, the \(0\)-turn
winning-condition problem is that of checking properness of colorings, called
the \Problem{3-Coloring Properness} problem, or \ColProp{} for short:

\begin{problem}{\Problem{3-Coloring Properness} / \ColProp}{}

  \begin{description}[nosep]
  \item[Given:] a 3-colored graph \((Œì,Œ∫)\) (specified by listing out each
    vertex with its color)
  \item[Determine whether:] \(Œ∫\) is a proper coloring
  \end{description}

  %\tcblower
  %\ColProp=\SetBuilder{(\text{graph \(Œì\)},\text{coloring \(Œ∫\)})}{
  %  ‚àÄ(u,v)‚àà\Edges(Œì)\Q Œ∫(u)‚â†Œ∫(v)
  %}
\end{problem}

In order for \ColProp{} to be usable as a basis for polynomial-hierarchy games,
we must first ensure that it itself is in \P.  Indeed, it is:

\begin{theorem}{\(\ColProp‚àà\P\)}{3colprop-in-p}

  \(\ColProp\) is solvable in polynomial time.

\end{theorem}

\begin{proof}

  We describe below a straightforward polynomial-time algorithm computing
  \ColProp.  Simply iterate through and verify properness on each edge:

  \begin{algorithm}{a polynomial-time \ColProp{} solver}{}
    \begin{algorithmic}
      \Given{a graph \(Œì\) and a coloring \(Œ∫\colon\Vertices(Œì)‚Üí\Colors\)}%
      \ForEach{\((u,v)‚àà\Edges(Œì)\)}%
      \If{\(Œ∫(u)=Œ∫(v)\)}%
      \LComment{\((u,v)\) is improper!}
      \State{\Return no}%
      \EndIf%
      \EndFor%
      \LComment{all edges have been checked, no improper ones were found; the
      coloring is proper}
      \State{\Return yes}%
    \end{algorithmic}
  \end{algorithm}

  The number of edges is, by definition, bounded by the size of the graph, so
  the number of ``for each'' iterations is polynomial. Within each iteration,
  the \(Œ∫(u)=Œ∫(v)\) check runs within polynomial time, so the overall algorithm
  runs in polynomial time as well.  \qedhere

\end{proof}

\section{The \(ùëò\)-turn games}



A graph coloring game is played on an initially uncolored graph \(Œì\).  In a
\(k\)-turn game, the graph's vertices are partitioned into \(k\) groups,
\(V‚ÇÅ,V‚ÇÇ,\dotsc,V‚Çñ\), and players alternate turns assigning colors to the
vertices in each group.  If, on any turn, a player introduces an improper edge
in the (partial) coloring, the other player wins.  If, after all turns, no
improper edges have been introduced---that is, the resulting coloring is
proper---then the \emph{last} player wins.

To help formalize this game, we define exactly what we mean by \emph{partial
coloring}.

\begin{definition}{partial (vertex 3-)colorings}{}

  Let \(Œì\) be a graph.  A \Term{partial (vertex 3-)coloring} is a map
  \(Œ∫\colon\Vertices(Œì)‚Üí\ColorsOpt\), which \emph{optionally} assigns a color to
  each vertex in \(Œì\) (\None{} means no color is assigned).  Where necessary,
  we refer to fully-completed colorings as \Term{total colorings} to
  differentiate them from partial colorings.

  A partial coloring \(Œ∫\) is \Term{proper} if, among the vertices it
  \emph{does} assign a color, there are no improper edges.  That is, for all
  \((u,v)‚àà\Edges(Œì)\), if both \(Œ∫(u)\) and \(Œ∫(v)\) are not \None, then
  \(Œ∫(u)‚â†Œ∫(v)\).

\end{definition}

At the start of the game, no vertices are colored yet---the partial coloring
assigns \None{} to every vertex.  When a player makes a move, they
\emph{augment} the partial coloring with new assignments:

\begin{definition}{augmented coloring}{}

  Let \(Œì\) be a graph, and \(Œ∫\) be a partial coloring on \(Œì\).

  Let \(U‚äÜ\Vertices(Œì)\) be a subset of the vertices such that, for each
  \(u‚ààU\), \(Œ∫(u)=\None\) (all vertices in \(U\) are uncolored), and let
  \(Œ¥\colon U‚Üí\Colors\) be an assignment of colors to every vertex in \(U\).
  Then the \Term{augmented coloring \(Œ∫[Œ¥]\colon\Vertices(Œì)‚Üí\ColorsOpt\)} is
  another partial coloring formed by the combining the two color assignments:
  \[
    Œ∫[Œ¥](v) =
    \begin{cases}
      Œ¥(v) & v‚ààU \\
      Œ∫(v) & v‚àâU
    \end{cases}.
  \]

  For any partial coloring \(Œ∫'\), we say \(Œ∫'\) is an \Term{extension} of \(Œ∫\)
  if there exists some \(Œ¥\colon U‚Üí\Colors\) such that \(Œ∫'=Œ∫[Œ¥]\).

\end{definition}

Now, we are ready to give the full inductive formulation of \(k\)-turn graph
coloring games.
\begin{itemize}

  \item The \(0\)-turn winning condition is \ColProp: given a totally-colored
    graph, decide whether the coloring is proper.

  \item \(k\)-turn games begin on a partially-colored graph \((Œì,Œ∫)\), where the
    partial coloring \(Œ∫\) comprises color assignments made in previous turns.
    (We discuss in \cref{sec:precolor} restrictions of these games to entirely
    uncolored graphs.)

    If \(Œ∫\) is improper to begin with, then we posit that the first player
    automatically wins, since that means that the opposite player must have made
    an improper move on their previous turn. Otherwise, the first player colors
    \(U‚ÇÅ\) with a coloring \(Œ¥\), and wins if and only if the remaining
    \((k-1)\)-turn game \(\Paren*{Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ)}\) is now un-winnable by
    the opposite player.
\end{itemize}


%In \cref{sec:pre-coloring}, we discuss how to
%restrict this formulation to games that start on empty graphs.

%Thus we start with a graph \(Œì\) and a partial coloring \(Œ∫\) of \(Œì\).  The
%\emph{uncolored} vertices in \(Œì\) are partitioned into \(k\) groups,
%\(U‚ÇÅ,U‚ÇÇ,\dotsc,U‚Çñ\).  For each turn \(i\) in \(1,2,\dotsc,k\), player
%\((i\bmod2)\) assigns colors to all vertices in \(U·µ¢\).  If, when doing so, they
%introduce an improper edge, they lose; otherwise, the game proceeds.  If all
%turns finish, and the resulting total coloring is proper, the last player wins.

%\begin{enumerate}
%  \item On the first turn, the first player assigns a coloring \(Œ¥‚ÇÅ\) to \(U‚ÇÅ\),
%    producing a new partial coloring \(Œ∫'=Œ∫[Œ¥‚ÇÅ]\).  If \(Œ∫'\) is improper, then
%    the first player automatically loses; otherwise, the game continues.
%  \item[{[\(2\)--\(k\)]}] The remaining \(k-1\) turns proceed inductively,
%    starting with the new partial coloring \(Œ∫'\), with the first move made by
%    the second player.
%\end{enumerate}
%At the end of all turns, if the resulting coloring is improper, the player who
%introduced the improper edge loses; otherwise, the last player wins.  The
%decision problem: does the first player have a winning strategy?

\begin{problem}{\Problem{3-Colorability} with \(k\) turns / \Col[k]}{}

  For \(k=0\), define \(\Col[0]=\ColProp\Complement\).  For \(k‚â•1\), define
  \(\Col[k]\) as follows:

  \tcblower

  \begin{description}[nosep]
    \item[Given:] a partially-colored graph and a partitioning of its uncolored
      vertices, 
      \begin{nest}
        \((Œì,Œ∫,(U‚ÇÅ,U‚ÇÇ,\dotsc,U‚Çñ))\)
      \end{nest}
    \item[Determine whether:] \(Œ∫\) is improper, or there exists some \(Œ¥\colon
      U‚ÇÅ‚Üí\Colors\) such that
      \begin{nest}
        \(\Paren*{Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ)}‚àà\Paren*{\Col[k-1]}\Complement\)
      \end{nest}
    \end{description}

\end{problem}

Pay particular attention to the fact that \(\Col[0]\) is defined as the
\emph{complement} of \ColProp‚Äîthat is, return ``yes'' if the graph coloring is
\emph{improper}. This might seem a little weird, but using
\(\ColProp\Complement\) rather than \ColProp{} as the ``base case'' game turns
out to be the more natural definition: it matches the \(k‚â•1\) definition better
(specifically, the first half of the winning condition, ``\(Œ∫\) is improper'')
overall makes generalizations on \Col[k] cleaner to state and prove.

\section{\(k\)-turn \Problem{3-Colorability} is in \texorpdfstring{\SigmaP k}{ùö∫‚Çñùêè}, right?}

Having defined \(\Col[k]\) as a \(k\)-turn game problem, we naturally expect
that \(\Col[k]‚àà\SigmaP k\) (the class of all (``reasonable'') \(k\)-turn game
problems).  Indeed, we claim it is, but it isn't immediately obvious \emph{how}.
Specifically, membership in \(\Col[k]\) is conditioned on an extra ``\(Œ∫\) is
improper or'' clause that isn't present in the definition of \SigmaP k problems
(\cref{def:ph}):
\[
  \begin{array}{r@{\;=\;\Big\{\,}c@{\;\Big\vert\;}c@{\quad‚àÉ}r@{\Q}c@{\:‚àà\:}c@{\,\Big\},}}
    \Col[k] & (Œì,Œ∫,\dotsc) & \underline{\text{\(Œ∫\) is improper, or}} & Œ¥ &
    (Œì,Œ∫[Œ¥],\dotsc) & \Paren*{\Col[k-1]}\Complement \\[.5em]
    \Ub[‚àà\SigmaP k]{Œ†} & B && M & (B,M) & \Ub[‚àà\PiP{k-1}]{Œ†'}
  \end{array}
\]

By splitting up the two conditions, we can think of \Col[k] \emph{union} of two
problems:
\[
  \Col[k] = \SetBuilder{(Œì,Œ∫,\dotsc)}{\text{\(Œ∫\) is improper}}
  ‚à™ \SetBuilder*{(Œì,Œ∫,\dotsc)}{‚àÉŒ¥\Q(Œì,Œ∫[Œ¥],\dotsc)‚àà\Col[k-1]}
\]
The first term in the union, determining improperness of \(Œ∫\), is basically
equivalent to \(\ColProp\Complement\), which is in \P{} (\cref{th:3colprop-in-p}
and \cref{cor:p-cop}).  Meanwhile, the second term appears to comply with the
\SigmaP k definition---if we assume (yet unproven, but sort of as an inductive
hypothesis) that \(\Col[k-1]‚àà\SigmaP{k-1}\), then the second term is indeed in
\(\SigmaP k\).

So \Col[k] is the union of a problem in \P{} with a problem \emph{allegedly} in
\SigmaP k.

Then, it makes sense to expect \(\Col[k]‚àà\SigmaP k\) for the following
(conjectured) reasons:
\begin{itemize}
  \item We expect \(\P‚äÜ\SigmaP k\): any game with \(0\) turns can be thought of
    as game with \(k\) no-op turns. More generally, any \(k\)-turn game is also
    a \((k+1)\)-turn game, with an extra no-op move by the first (or last)
    player; games with fewer turns are no harder than games with more turns.
  \item The union of two problems in \SigmaP k should also be in \SigmaP k
    (i.e., \SigmaP k is \emph{closed} under union): intuitively, directly
    combining two problems doesn't make them harder.
\end{itemize}
Below, we state these conjectures in general terms and prove them.

\begin{theorem}{polynomial hierarchy inclusions}{fewer-easier}

  For every \(k=0,1,2,\dotsc\),
  \[
    \SigmaP k‚äÜ\SigmaP{k+1}, \qquad
    \SigmaP k‚äÜ\PiP{k+1}, \qquad
    \PiP k‚äÜ\SigmaP{k+1}, \qquad
    \PiP k‚äÜ\PiP{k+1}.
  \]

\end{theorem}

\begin{proof}

  We prove each of the four inclusions separately.
  \begin{enumerate}
    \item \label{it:fewer.ps} Claim: \(\PiP k‚äÜ\SigmaP{k+1}\).

      This follows directly from the definition of \(\SigmaP{k+1}\).  Let
      \(Œ†‚àà\PiP k\), and define
      \[
        Œ†'=\SetBuilder{(X,\text{\color{gray}(empty)})}{X‚ààŒ†}, \qquad p(n)=0.
      \]
      Note that \(Œ†'\) is the same problem as \(Œ†\), differing only in
      ``formatting'' of inputs, so \(Œ†'‚àà\PiP k\) as well.  Thus \(Œ†\) fits the
      definition of a \(\SigmaP{k+1}\) game:
      \begin{nest}
        For all inputs \(X‚àà\Strings\), \(X‚ààŒ†\) if and only if
        \begin{nest}
          letting \(Y\) be the empty string, we have \(\Abs Y=0‚â§p(\Abs X)\), and
          \begin{nest}
            \((X,Y)=(X,\text{\color{gray}(empty)})‚ààŒ†'\).
          \end{nest}
        \end{nest}
      \end{nest}
      Thus \(Œ†‚àà\SigmaP{k+1}\).

      \begin{aside}
        The intuition here: \(Œ†‚àà\PiP k\) is an impossible-to-win \(k\)-turn
        game.  Then, \(Œ†'\) is a \((k+1)\)-turn game in which, on the first
        turn, the other player does \emph{nothing}. Still, they guarantee a win,
        because the remaining game already dooms the second player to a loss.
      \end{aside}

    \item Claim: \(\SigmaP k‚äÜ\PiP{k+1}\).

      This follows directly from the previous result \ref{it:fewer.ps}, since
      \(\SigmaP k=\co\PiP k\) and \(\PiP{k+1}=\co\SigmaP{k+1}\).

    \item \label{it:fewer.ss} Claim: \(\SigmaP k‚äÜ\SigmaP{k+1}\).

      We prove this by induction on \(k\).
      \begin{itemize}
        \item For \(k=0\), \(\SigmaP0=\P=\PiP0\) by definition.  Thus the
          argument from part \ref{it:fewer.ps} applies in this case:
          \(\SigmaP0=\PiP0‚äÜ\SigmaP1\).
        \item For \(k‚â•1\), assume \(\SigmaP{k-1}‚äÜ\SigmaP k\). Suppose
          \(Œ†‚àà\SigmaP k\).  Then there exists a \(Œ†'‚àà\PiP{k-1}\) and a
          polynomial \(p\) such that
          \[
            Œ†=\SetBuilder{X}{‚àÉY\Q \Abs Y‚â§p(\Abs X), \quad (X,Y)‚ààŒ†'}.
          \]
          Recalling that \(\mathbf{Œ†}\) is just \(\co\mathbf{Œ£}\), the induction
          hypothesis implies \(\PiP{k-1}‚äÜ\PiP k\).  Thus \(Œ†'‚àà\PiP{k-1}\) is
          also in \(\PiP k\).  Consequently, \(Œ†\) is also in \(\SigmaP{k+1}\).
          Since \(Œ†\) was arbitrary, we conclude \(\SigmaP k‚äÜ\SigmaP{k+1}\).
      \end{itemize}

    \item Claim: \(\PiP k‚äÜ\PiP{k+1}\).

      This follows directly from the previous result \ref{it:fewer.ss}, since
      \(\mathbf{Œ†}=\co\mathbf{Œ£}\).  \qedhere

  \end{enumerate}

\end{proof}

As a side note, \ref{th:fewer-easier} justifies calling the collection of
complexity classes \SigmaP k/\PiP k a \emph{hierarchy}---each level of the
hierarchy is contained within the next, etc.  The following diagram illustrates
this hierarchy of containments:

\begin{center}
  \begin{tikzpicture}

    \tikzset{
      subset/.style={->},
    }

    \matrix[row sep=1em, column sep=4em, matrix of math nodes, nodes={
      draw, draw opacity=1/2, rounded corners=1em/4,
    }]{
      & |(s1)|\SigmaP1=\NP & |(s2)|\SigmaP2 & |(s3)|\SigmaP3 & |(s)[draw=none]|\cdots \\
      |(0)|\SigmaP0=\PiP0=\P & \\
      & |(p1)|\PiP1=\co\NP & |(p2)|\PiP2 & |(p3)|\PiP3 & |(p)[draw=none]|\cdots \\
    };

    \draw[subset] (0) to["\(‚äÜ\)" {above, sloped}] (s1);
    \draw[subset] (0) to["\(‚äÜ\)" {below, sloped}] (p1);

    \foreach \i in {p,s} {
      \foreach \j in {p,s} {
        \draw[subset] (\i1) to (\j2);
        \draw[subset] (\i2) to (\j3);
        \draw[subset] (\i3) to (\j);
      }
    }

  \end{tikzpicture}
\end{center}

%
%\begin{proof}
%
%  %Let \(Œ†‚àà\SigmaP k\); we wish to show that \(Œ†‚àà\SigmaP{k+1}\).
%
%  %Define the problem
%  %\[
%  %  Œ†'=\SetBuilder{(X,œµ)}{X‚ààŒ†},
%  %\]
%  %where \(œµ\) denotes the empty string.  First, note that \(Œ†'\) is trivially
%  %equivalent to \(Œ†\), differing only in the ``formatting'' of instances.  Thus
%  %\(Œ†'‚àà\SigmaP k\) as well.  Next, observe that \(Œ†'\) is polynomially balanced,
%  %since the second element \(œµ\) always has length \(0\).
%
%  %Then we see that \(Œ†\) fits the definition of a \SigmaP{k+1} problem:
%  %\begin{nest}
%  %  there is a polynomially-balanced problem in \(\SigmaP k\), namely \(Œ†'\)
%  %  such that
%  %  \begin{nest}
%  %    for every \(X‚àà\Strings\), \(X‚ààŒ†\) if and only if
%  %    \begin{nest}
%  %      there exists a \(Y‚àà\Strings\), in this case \(œµ\), with \((X,œµ)‚ààŒ†'\).
%  %    \end{nest}
%  %  \end{nest}
%  %\end{nest}
%
%  %Since \(Œ†‚àà\SigmaP k\) was arbitrarily chosen, this inclusion holds for all
%  %problems in \(\SigmaP k\).  Thus \(\SigmaP k‚äÜ\SigmaP{k+1}\).
%
%  %The inclusion \(\PiP k‚äÜ\PiP{k+1}\) follows directly, then, from the definition
%  %of \PiP k/\PiP{k+1}.
%  %\[
%  %  \PiP k=\co\SigmaP k‚äÜ\co\SigmaP{k+1}=\PiP{k+1}.  \qedhere
%  %\]
%
%\end{proof}
%
\begin{theorem}{\(\SigmaP k\) and \(\PiP k\) are closed under union, intersection}{ph-closure}

  If \(Œ†‚ÇÅ,Œ†‚ÇÇ‚àà\SigmaP k\), then \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ\) and \(Œ†‚ÇÅ‚à©Œ†‚ÇÇ\) are
  both in \(\SigmaP k\).

  Likewise, if \(Œ†‚ÇÅ,Œ†‚ÇÇ‚àà\PiP k\), then \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ\) and \(Œ†‚ÇÅ‚à©Œ†‚ÇÇ\) are both in \(\PiP
  k\).

\end{theorem}

\begin{proof}

  By induction on \(k\).
  \begin{itemize}

    \item For \(k=0\), let \(Œ†‚ÇÅ,Œ†‚ÇÇ‚àà\SigmaP0=\PiP0=\P\); we wish to show that
      \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ,Œ†‚ÇÅ‚à©Œ†‚ÇÇ‚àà\P\).

      Let \(A‚ÇÅ,A‚ÇÇ\) be polynomial-time algorithms deciding \(Œ†‚ÇÅ,Œ†‚ÇÇ\)
      respectively.  To decide \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ\), run the two algorithms in sequence,
      returning ``yes'' if at least one of the two algorithms returns ``yes'';
      to decide \(Œ†‚ÇÅ‚à©Œ†‚ÇÇ\), return ``yes'' if both return ``yes''.

      \begin{algorithm}{decider for union or intersection of two \P{} problems}{}
        \begin{algorithmic}
          \Given{an arbitrary input string \(X‚àà\Strings\)}
          \State{\(y‚ÇÅ‚ÜêA‚ÇÅ(X)\)}
          \State{\(y‚ÇÇ‚ÜêA‚ÇÇ(X)\)}
          \If{deciding \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ\)}
          \State{\Return ``yes'' if at least one of \(y‚ÇÅ,y‚ÇÇ\) is ``yes'' (i.e., \(y‚ÇÅ‚à®y‚ÇÇ\))}
          \ElsIf{deciding \(Œ†‚ÇÅ‚à©Œ†‚ÇÇ\)}
          \State{\Return ``yes'' if both \(y‚ÇÅ,y‚ÇÇ\) are ``yes'' (i.e., \(y‚ÇÅ‚àßy‚ÇÇ\))}
          \EndIf
        \end{algorithmic}
      \end{algorithm}

      This algorithm runs in polynomial time because both \(A‚ÇÅ\) and \(A‚ÇÇ\) run
      in polynomial time; the overall running time is a sum of two polynomials
      (plus some constants for the last comparison), which is still a
      polynomial.  Thus \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ,Œ†‚ÇÅ‚à©Œ†‚ÇÇ‚àà\P\).

    \item Suppose that the claim holds for all levels below some \(k‚â•1\).
      First, we show that \(\SigmaP k\) is closed under union and intersection.

      Let \(Œ†‚ÇÅ,Œ†‚ÇÇ‚àà\SigmaP k\). Then there exist \(Œ†‚ÇÅ',Œ†‚ÇÇ'‚àà\PiP{k-1}\) and
      polynomials \(p‚ÇÅ,p‚ÇÇ\) such that
      \begin{align*}
        Œ†‚ÇÅ&=\SetBuilder*{X}{‚àÉY\Q\Abs Y‚â§p‚ÇÅ(\Abs X), \quad (X,Y)‚ààŒ†‚ÇÅ'}, \\
        Œ†‚ÇÇ&=\SetBuilder*{X}{‚àÉY\Q\Abs Y‚â§p‚ÇÇ(\Abs X), \quad (X,Y)‚ààŒ†‚ÇÇ'}.
      \end{align*}

      Define two new problems
      \begin{align*}
        Œ†‚ÇÅ''&=\SetBuilder*{(X,(Y‚ÇÅ,Y‚ÇÇ))}{(X,Y‚ÇÅ)‚ààŒ†‚ÇÅ'}, \\
        Œ†‚ÇÇ''&=\SetBuilder*{(X,(Y‚ÇÅ,Y‚ÇÇ))}{(X,Y‚ÇÇ)‚ààŒ†‚ÇÇ'}.
      \end{align*}
      Notice that \(Œ†·µ¢''\) is the same problem as \(Œ†·µ¢'\), differing only in
      that it takes in and ignores an additional component in the input.
      Therefore, they are equivalent; \(Œ†·µ¢'‚àà\PiP{k-1}\) implies
      \(Œ†·µ¢''‚àà\PiP{k-1}\) as well.

      Now, construct the problems
      \begin{align*}
        Œ†_‚à™&=\SetBuilder*{X}{‚àÉ(Y‚ÇÅ,Y‚ÇÇ)\Q(X,(Y‚ÇÅ,Y‚ÇÇ))‚ààŒ†‚ÇÅ''‚à™Œ†‚ÇÇ''}, \\
        Œ†_‚à©&=\SetBuilder*{X}{‚àÉ(Y‚ÇÅ,Y‚ÇÇ)\Q(X,(Y‚ÇÅ,Y‚ÇÇ))‚ààŒ†‚ÇÅ''‚à©Œ†‚ÇÇ''}.
      \end{align*}
      By the induction hypothesis, \(\PiP{k-1}\) is closed under union and
      intersection, so \(Œ†‚ÇÅ''‚à™Œ†‚ÇÇ'',Œ†‚ÇÅ''‚à©Œ†‚ÇÇ''‚àà\PiP{k-1}\).  Additionally, the
      length of the second component \((Y‚ÇÅ,Y‚ÇÇ)\) is bounded by \(p‚ÇÅ+p‚ÇÇ\) (plus
      some constants to account for delimiters), polynomial in the size of the
      ``board'' \(X\).  Thus \(Œ†_‚à™,Œ†_‚à©‚àà\SigmaP k\).

      Finally, we claim that \(Œ†_‚à™=Œ†‚ÇÅ‚à™Œ†‚ÇÇ\), and \(Œ†_‚à©=Œ†‚ÇÅ‚à©Œ†‚ÇÇ\).  We show both
      equalities below.
      \begin{itemize}
        \item Claim: \(Œ†_‚à™=Œ†‚ÇÅ‚à©Œ†‚ÇÇ\).  The following statements are equivalent:
          \begin{itemize}[nosep]
            \item \(X‚ààŒ†_‚à™\).
            \item There exists \((Y‚ÇÅ,Y‚ÇÇ)\) so that \((X,(Y‚ÇÅ,Y‚ÇÇ))\) is in either
              (or both) of \(Œ†‚ÇÅ'',Œ†‚ÇÇ''\).
            \item There exists \(Y‚ÇÅ\) so that \((X,Y‚ÇÅ)‚ààŒ†‚ÇÅ'\), or there exists
              \(Y‚ÇÇ\) so that \((X,Y‚ÇÇ)‚ààŒ†‚ÇÇ'\).
            \item \(X‚ààŒ†‚ÇÅ\) or \(X‚ààŒ†‚ÇÇ\).
            \item \(X‚ààŒ†‚ÇÅ‚à™Œ†‚ÇÇ\).
          \end{itemize}

        \item Claim: \(Œ†_‚à©=Œ†‚ÇÅ‚à©Œ†‚ÇÇ\).  The following are equivalent:
          \begin{itemize}[nosep]
            \item \(X‚ààŒ†_‚à©\).
            \item There exists \((Y‚ÇÅ,Y‚ÇÇ)\) so that \((X,(Y‚ÇÅ,Y‚ÇÇ))\) is in both of
              \(Œ†‚ÇÅ'',Œ†‚ÇÇ''\).
            \item There exists \(Y‚ÇÅ\) so that \((X,Y‚ÇÅ)‚ààŒ†‚ÇÅ'\), and there exists
              \(Y‚ÇÇ\) so that \((X,Y‚ÇÇ)‚ààŒ†‚ÇÇ'\).
            \item \(X‚ààŒ†‚ÇÅ\) and \(X‚ààŒ†‚ÇÇ\).
            \item \(X‚ààŒ†‚ÇÅ‚à©Œ†‚ÇÇ\).
          \end{itemize}

      \end{itemize}

      This concludes the main proof: for any \(Œ†‚ÇÅ,Œ†‚ÇÇ‚àà\SigmaP k\), both
      \(Œ†‚ÇÅ‚à™Œ†‚ÇÇ=Œ†_‚à™\) and \(Œ†‚ÇÅ‚à©Œ†‚ÇÇ=Œ†_‚à©\) are in \(\SigmaP k\), as desired.  Thus
      \(\SigmaP k\) is closed under union and intersection.

      Closure of \(\PiP k\) under union and intersection follows from \(\PiP
      k=\co\SigmaP k\), and from DeMorgan's set identities:
      \[
        \Paren*{Œ†‚ÇÅ‚à™Œ†‚ÇÇ}\Complement=Œ†‚ÇÅ\Complement‚à©Œ†‚ÇÇ\Complement, \qquad
        \Paren*{Œ†‚ÇÅ‚à©Œ†‚ÇÇ}\Complement=Œ†‚ÇÅ\Complement‚à™Œ†‚ÇÇ\Complement.  \qedhere
      \]

  \end{itemize}

\end{proof}

We may now confidently conclude, having proven these two theorems, that
\(\Col[k]‚àà\SigmaP k\).  We discussed why earlier, but just to be thorough, we
restate the full proof below.

\begin{corollary}{}{col-in-sigma}

  \(\Col[k]‚àà\SigmaP k\).

\end{corollary}

\begin{proof}

  By induction on \(k\).
  \begin{itemize}
    \item For \(k=0\), we have \(\Col[0]=\ColProp\Complement‚àà\P=\SigmaP0\).
    \item For some \(k‚â•1\), assume \(\Col[k-1]‚àà\SigmaP{k-1}\).  We have
      \[
        \Col[k]
        = \SetBuilder{(Œì,Œ∫,\dotsc)}{\text{\(Œ∫\) is improper}}
        ‚à™ \SetBuilder*{(Œì,Œ∫,\dotsc)}{‚àÉŒ¥\Q(Œì,Œ∫[Œ¥],\dotsc)‚àà\Paren*{\Col[k-1]}\Complement}.
      \]
      The first set in the union is equivalent to \(\ColProp\Complement\), which
      is in \(\P\) and therefore also in \(\SigmaP k\) (\cref{th:fewer-easier}).
      The second set in the union is by construction a \(\SigmaP k\) problem,
      since \(\Paren*{\Col[k-1]}\Complement‚àà\PiP{k-1}\).  Thus the union of the
      two is also in \SigmaP k (\cref{th:ph-closure}). \qedhere
  \end{itemize}

\end{proof}

Of course, \cref{th:fewer-easier,th:ph-closure} are useful beyond \Col[k]; they
make it much more convenient for us to construct and describe \SigmaP k/\PiP k
problems in general.  One important use-case, as exemplified by \Col[k], is for
incorporating game rules checked at \emph{each turn} of gameplay, rather than
only at the end after all turns have been played.  These rules, for example, can
stipulate conditions on what types of moves are valid, shortcuts to
winning/losing, etc.


%Unsurprisingly, \(\Col[k]‚àà\SigmaP k\).  This inclusion follows straightforwardly
%from the construction of \Col[k] as a \(k\)-turn game; we give a rigorous proof
%below by showing that it complies to the definition of \SigmaP k.
%
%\begin{proof}
%
%  For each \(k=0,1,\dotsc\), define \(\Col[k]'\) to be a modified version of
%  \Col[k] in which the first player automatically wins if the starting coloring
%  is invalid:
%  \[
%    \Col[k]' = \SetBuilderLong{(Œì,Œ∫,(U‚ÇÅ,\dotsc,U‚Çñ))}{
%      \text{\(Œ∫\) is improper, or \(‚àÉŒ¥\colon U‚ÇÅ‚Üí\Colors\Q(Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))‚àâ\Col[k-1]'\)}
%    }
%  \]
%
%  When \(k=0\), there are no uncolored vertices, and \(Œ∫\) is a total coloring.
%  Then \(\Col[0]'\) is simply the set of improperly colored graphs, the
%  complement of \ColProp:
%  \[
%    \Col[0]' = \SetBuilder{(Œì,Œ∫)}{\text{\(Œ∫\) is improper}} = \ColProp\Complement.
%  \]
%  Since \(\ColProp‚àà\P\) (\cref{th:3colprop-in-p}), we know that
%  \(\Col[0]'=\ColProp\Complement\) is also in \(\P=\SigmaP0\).
%
%  TODO
%
%\end{proof}
%





%Given a graph \(G\) along with a \(3\)-coloring on \(G\), is the coloring
%proper?  We can solve this problem by simply checking, for each edge, whether
%the two vertices on that edge have different colors.  The run-time of this
%solution is \(\O(e)\) and therefore polynomially-bounded in the size of \(G\).
%Thus the problem of \emph{checking} whether a given \(3\)-coloring is proper is
%in \P.
%
%\subsection{The \(3\)-coloring puzzle}
%
%The puzzle-ification of this problem comes in the following form:
%\begin{definition}[\Problem{3col}]%
%  Given a graph \(G\), is there a way to properly \(3\)-color the vertices of
%  \(G\)?
%  \[
%    \Problem{3col} = \SetBuilder* G {
%      ‚àÉ\,\text{coloring \(C = (c_1,\dotsc,c_n) ‚àà \Set{0,1,2}^n\)} \quad \text{\(C\) is proper}
%    }
%  \]
%\end{definition}
%It is straightforward to see from its definition and the fact that
%properness-checking is in \P{} that \(\Problem{3col} ‚àà \NP\).
%
%The natural question to ask is: is it also \NP-complete?  After all, earlier,
%we could confidently expect that \NP-completeness from \emph{Boolean} \CircSat{}
%because of the universality of Boolean logic, but, at a glance, it isn't
%obvious that graphs and proper colorings are somehow ``fundamental'' to
%computation as Booleans are.  But, in fact, that is exactly the case:
%\begin{theorem}
%  \Problem{3col} is \NP-complete.
%\end{theorem}
%
%\section{Reduction from CSAT}

\section{\(k\)-turn \Problem{3-Colorability} is \texorpdfstring{\SigmaP k}{ùö∫‚Çñùêè}-complete}

So, we just showed that \(\Col[k]‚àà\SigmaP k\).  But that's hardly surprising:
given what we understand now about \SigmaP k/\PiP k, almost anything we can
conceive of as a \(k\)-turn game---that is, with polynomial-time-checkable
rules, and \(k\) fixed turns of reasonable size---most likely falls within
\SigmaP k/\PiP k.

Really, the more interesting, more profound result is that \Col[k] is among the
\emph{hardest} \(k\)-turn games: it is \emph{\SigmaP k-complete}.  Before
jumping into the proof of this claim, we first discuss the key idea behind
it: graph 3-colorings are powerful enough to ``encode'' boolean circuits.

\subsection{Using 3-colorings to emulate circuits}

Graph 3-colorings can \emph{emulate} boolean circuits. To illustrate what this
means, associate each boolean value with a color: we take the (convenient)
convention that \ColorId0 means \False{} and \ColorId1 means \True{} (\ColorId2
is an ``auxiliary'' color used to enforce intermediate constraints but never to
represent a boolean value). Then, it is possible to convert any boolean circuit
into a graph so that properness on the graph's colorings causes them to exactly
compute the circuit.

We define this idea more precisely below.

\begin{definition}{boolean 3-coloring graphs}{boolean-graph}

  Let \(Œì\) be a graph, and let \(Œ∫\) be a proper \emph{partial} coloring on
  \(Œì\).

  A vertex \(v\) is called a \Term{boolean vertex} if \(v\) neighbors some
  vertex \(v'\) such that \(Œ∫(v')=\ColorId2\).

  Assume \(Œì\) contains the following ``special'' boolean vertices:
  \begin{itemize}[nosep]
    \item \(n\) distinct \Term{input vertices} \(ùíä‚ÇÅ,\dotsc,ùíä‚Çô\);
    \item an \Term{output vertex} \(ùíê\).
  \end{itemize}
  We call any non-input/output vertex as a \Term{internal vertex} of \(Œì\).

  Let \(Œ∫'\) be an arbitrary proper total coloring that \emph{extends} \(Œ∫\).
  For each input or output vertex \(v\), since \(v\) neighbors a (pre-colored)
  \ColorId2 by construction and \(Œ∫'\) is proper, we know \(Œ∫'(v)‚àà\TF\).  We say
  the \Term{boolean value} assigned by \(Œ∫'\) to \(v\) is \(\True\) if
  \(Œ∫'(v)=\ColorId1\), and \False{} if \(Œ∫'(v)=\ColorId0\).

  %Now, let \(Œ∫\colon\Vertices(G)‚Üí\Set{0,1,2}\) be an arbitrary \emph{proper}
  %3-coloring.  Because the three special vertices \(s_\True,s_\False,s_\Aux\)
  %are joined by a triangle, we know that \(Œ∫\) assigns them all three
  %(distinct) available colors.

  %For each input/output vertex \(v\), since \(v\) neighbors \(s_\Aux\) by
  %construction, we know \(Œ∫(v)‚â†Œ∫(s_\Aux)\); then, since there are only three
  %colors, we know \(Œ∫(v)\) must equal \(Œ∫(s_\True)\) or \(Œ∫(s_\False)\).  We
  %say the \Term{boolean value} assigned (by \(Œ∫\)) to each input/output vertex
  %\(v\) is \(\True\) if \(Œ∫(v)=Œ∫(s_\True)\) and \(\False\) if
  %\(Œ∫(v)=Œ∫(s_\False)\).

  To simplify notation, we will conflate the colors \ColorId1/\ColorId0 with
  their corresponding boolean values \True/\False (respectively), except where
  the distinction is needed for clarity.

  Next, let \(œï\colon\TF[n]‚Üí\TF\) be a boolean function.  We say that \(Œì\)
  \Term{computes} \(œï\) if the following properties hold:
  \begin{description}[nosep]
  \item[Attainability] For every combination of boolean values
    \((x‚ÇÅ,\dotsc,x‚Çô)\in\TF[n]\), there exists at least one proper 3-coloring
    \(Œ∫\) such that \(Œ∫(ùíä‚±º)=x‚±º\) for each \(j=1,\dotsc,n\).
  \item[Consistency] For every proper coloring \(Œ∫\),
    \[
      Œ∫(ùíê)=œï(Œ∫(ùíä‚ÇÅ),Œ∫(ùíä‚ÇÇ),\dotsc,Œ∫(ùíä‚Çô)).
    \]
  \end{description}

  %For example, we may say \(Œ∫(v)=\True\) to really mean
  %\(Œ∫(v)=\ColorId1\), or write \(¬¨Œ∫(v)\) to mean the negation of \emph{the
  %boolean value of} \(v\) (despite \(Œ∫(v)\) being a color).

  %\(Œ∫(v)\) to
  %denote the boolean value of \(v\); i.e., \(Œ∫(v)=\True\)
\end{definition}

%\begin{definition}{boolean graphs as boolean functions}{boolean-graph-functions}%
%
%  Let \(G\) be a boolean graph.  We say that \(G\) computes a well-defined
%  boolean function \(œï\colon\Set{\True,\False}^n‚Üí\Set{\True,\False}\), if, for
%  every combination of boolean values \(x_1,\dotsc,x_n‚àà\Set{\True,\False}^n\),
%  the following hold:
%\end{definition}

%\begin{example}{A graph computing the boolean identity function}{}%
%  The following boolean graph computes the boolean identity function,
%  \(œï(x_1)=x_1\).
%  \begin{center}
%    \begin{tikzpicture}[x=3em, y=3em]
%      \coordinate[vertex](t) at (120:1);
%      \coordinate[vertex](f) at (60:1);
%      \coordinate[vertex](a);
%      \draw (t) -- (f) -- (a) -- (t);
%      \node[vertex label, left] at (t) {\(s_\True\)};
%      \node[vertex label, right] at (f) {\(s_\False\)};
%      \node[vertex label, left] at (a) {\(s_\Aux\)};
%
%      \coordinate[vertex](i) at (-90:1);
%      \node[vertex label, below] at (i.south) {\(i_1=o\)};
%      \draw (i) -- (a);
%    \end{tikzpicture}
%  \end{center}
%
%  TODO is explanation even needed, or is it actually obvious that this works?
%\end{example}

In order to convert circuits in general to boolean graphs, we start by
converting the basic building blocks of circuits.  As mentioned in the
definition, we represent each \emph{wire} to a boolean vertex, i.e. a vertex
joined to a pre-colored \ColorId2, so that it can only be colored \ColorId0 or
\ColorId1 (namely, a boolean value).

\begin{center}
  \begin{tikzpicture}
    \matrix[column sep=2em, row sep=1em]{
      \coordinate(x); & \coordinate(x'); & \node[opacity=1/2]{\(‚üº\)}; &
      \coordinate["above:\(x\)", vertex](vx); \\ &&& \coordinate[vertex, fill=ks2](aux); \\
    };
    \draw[wire] (x) -- (x') node[midway, above, vertex label]{\(x\)};
    \draw[edge] (vx) -- (aux);
  \end{tikzpicture}
\end{center}

To negate the boolean value of a vertex, create an edge joining the input and
output vertices, which forces them to have opposite colors:

\begin{definition}{\NOT{} graph}{not-graph}

  Let \(ùíä\) be a boolean vertex.  Construct a \Term{\NOT{} graph} on input \(ùíä\)
  by introducing a new boolean vertex \(ùíê\), i.e., the \emph{output} vertex, and
  an edge \(ùíä‚Üîùíê\).

  \begin{center}
    \begin{tikzpicture}
      \matrix[column sep=1em, row sep=1em]{
        \coordinate["above:\(ùíä\)"](x); & \node[gate](neg){\(¬¨\)}; & \coordinate["above:\(ùíê\)"](y); &[1em]
        \node[opacity=1/2]{\(‚üº\)}; &[1em]
        \coordinate[vertex](vx); && \coordinate[vertex](vy); \\
        &&&&& \coordinate[vertex, fill=ks2](aux); \\
      };
      \node[vertex label, above=0pt of vx]{\(ùíä\)};
      \node[vertex label, above=0pt of vy]{\(ùíê\)};
      \draw[wire, ->] (x) -- (neg);
      \draw[wire, -> ] (neg) -- (y);
      \draw[edge] (vx) -- (vy) -- (aux) -- (vx);
    \end{tikzpicture}
  \end{center}

\end{definition}

If, for whatever reason, we wish to replicate/propagate a boolean value across
multiple vertices (called a ``buffer'' gate), we can use two \NOT{} gates in a
row (\(¬¨¬¨x=x\)):

\begin{definition}{buffer graph}{buffer-graph}

  Let \(ùíä\) be a boolean vertex.  Construct a \Term{buffer graph} on input \(ùíä\)
  by creating two new vertices, \(\bar i\) and \(ùíê\) (the \emph{output}), and
  edges \(ùíä‚Üî\bar ùíä‚Üîùíê\).

  \begin{center}
    \begin{tikzpicture}
      \matrix[column sep=1em, row sep=1em]{
        \coordinate["above:\(ùíä\)"](x); & \coordinate["above:\(ùíê\)"](y); &[1em]
        \node[opacity=1/2]{\(‚üº\)}; &[1em]
        \coordinate[vertex](vx); &
        \coordinate[vertex](v); &
        \coordinate[vertex](vy); \\
        &&&& \coordinate[vertex, fill=ks2](aux); \\
      };
      \node[above=0pt of vx, vertex label]{\(ùíä\)};
      \node[above=0pt of vy, vertex label]{\(ùíê\)};
      \node[above=0pt of v, vertex label]{\(\bar i\)};
      \draw[wire, ->] (x) -- (y);
      \draw[edge] (v) -- (vx) -- (aux) -- (v) -- (vy) -- (aux);
    \end{tikzpicture}
  \end{center}

\end{definition}

\AND{} and \OR{} gates are somewhat trickier to implement as graphs. To help in
their construction, we first introduce an auxiliary graph that ``approximates''
\AND/\OR{} gates, which we call the \Term{semi-\OR{} graph}:

\begin{definition}{semi-\OR{} graph on two (boolean) vertices}{}

  Let \(x,y\) be boolean vertices.  The \Term{semi-\OR{} graph} on \(x,y\) is
  constructed as follows:
  \begin{itemize}[nosep]
    \item Create three vertices \(x',y',t\) and edges joining them in a
      triangle.
    \item Create edges \(x‚Üîx'\) and \(y‚Üîy'\).
    \item Pre-assign \(t\) the color \ColorId1.
  \end{itemize}

  \begin{center}
    \begin{tikzpicture}
      \matrix[row sep=1em, column sep=1em]{
        \coordinate[vertex](x); && \coordinate[vertex](x'); \\
        & \coordinate[vertex, fill=ks2](aux); && \coordinate[vertex, fill=ks1](t); \\
        \coordinate[vertex](y); && \coordinate[vertex](y'); \\
      };
      \node[above, vertex label] at (x.north) {\(x\)};
      \node[below, vertex label] at (y.south) {\(y\)};
      \node[above, vertex label] at (x'.north) {\(x'\)};
      \node[below, vertex label] at (y'.south) {\(y'\)};
      \node[right, vertex label] at (t.east) {\(t\)};
      \draw[edge] (x') -- (x) -- (aux) -- (y) -- (y') -- (t) -- (x') -- (y');
    \end{tikzpicture}
  \end{center}

\end{definition}

The semi-\OR{} graph is named as such because it \emph{constrains} at least one
of \(x,y\) to have the \ColorId1; no proper coloring exists if both \(x,y\) are
colored \ColorId0.  We state and prove this property below.

\begin{lemma}{}{semior2-constraint}

  Let \(x,y\) be boolean vertices, and let \(Œ∫\) be a proper coloring of the
  semi-\OR{} graph on \(x,y\).  Then it must \emph{not} be the case that
  \(Œ∫(x)=Œ∫(y)=\ColorId0\).

  In other words, the following implications hold:
  \begin{itemize}[nosep]
    \item If \(Œ∫(x)=\ColorId0\), then \(Œ∫(y)=\ColorId1\).
    \item If \(Œ∫(y)=\ColorId0\), then \(Œ∫(x)=\ColorId1\).
  \end{itemize}
  %Together, these two constraints imply that \(Œ∫(x)=Œ∫(y)=\ColorId0\) is
  %impossible (assuming \(Œ∫\) is indeed proper).

\end{lemma}

\begin{proof}

  Suppose towards a contradiction that \(Œ∫(x)=Œ∫(y)=\ColorId0\).  Then, \(x'\)
  and \(y'\), which neighbor \(x\) and \(y\) respectively, cannot be colored
  \(\ColorId0\).  Furthermore, \(x'\) and \(y'\) neighbor \(t\), which has color
  \(Œ∫(t)=\ColorId1\), so they also cannot be colored \(\ColorId1\).  Therefore,
  both \(x'\) and \(y'\) can only be colored \ColorId2.  However, they also
  neighbor each other, so they must receive different colors, a contradiction.
  \qedhere

  %First, suppose \(Œ∫(x)=\ColorId0\).  Then \(x'\), which is adjacent to \(x\)
  %(colored \ColorId0) and \(t\) (colored \ColorId1) must be colored \ColorId2, so \(y'\), adjacent to \(x'\) (colored \ColorId2) and \(t\) (colored \ColorId

\end{proof}

The semi-\OR{} graph doesn't yet behave like a \emph{real} \OR{} graph because,
in a real \OR{} graph, coloring \(x,y\) both \ColorId0 should merely cause the
output vertex to be colored \ColorId0, rather than rule out proper-colorability
altogether.

Multiple semi-\OR{} graphs can be ``stacked'' together to impose the the same
\OR-like colorability constraint on three or more boolean vertices.  For
example, we define below the semi-\OR{} graph on three vertices.

\begin{definition}{semi-\OR{} graph on three vertices}{}

  Let \(x,y,z\) be boolean vertices.  Construct the \Term{semi-\OR{} graph} on
  \(x,y,z\) as follows:
  \begin{itemize}
    \item Create vertices labeled \(x',y',t‚ÇÅ\) and edges joining them in a
      triangle.
    \item Create edges \(x‚Üîx'\) and \(y‚Üîy'\).
    \item Join \(t‚ÇÅ\) to another vertex pre-colored \ColorId2, thereby making
      \(t‚ÇÅ\) a boolean vertex.  This step differs from the two-vertex semi-\OR{}
      construction, wherein we would just pre-color \(t‚ÇÅ\) \ColorId1.
    \item  Create a two-vertex semi-\OR{} graph on \(t‚ÇÅ\) and \(z\).
  \end{itemize}

  \begin{center}
    \begin{tikzpicture}

      \matrix[row sep=1em, column sep=1em]{
        \coordinate[vertex](x); && \coordinate[vertex](x'); \\
        & \coordinate[vertex, fill=ks2](a1); && \coordinate[vertex](t1); && \coordinate[vertex](t1'); \\
        \coordinate[vertex](y); && \coordinate[vertex](y'); &&
        \coordinate[vertex, fill=ks2](a2); && \coordinate[vertex, fill=ks1](t2); \\
        &&& \coordinate[vertex](z); && \coordinate[vertex](z'); \\
      };

      \draw (x') -- (x) -- (a1) -- (y) -- (y') -- (x') -- (t1) -- (y');
      \draw (t1') -- (t1) -- (a2) -- (z) -- (z') -- (t1') -- (t2) -- (z');

      \node[above, vertex label] at (x.north) {\(x\)};
      \node[below, vertex label] at (y.south) {\(y\)};
      \node[below, vertex label] at (z.south) {\(z\)};
      \node[vertex label, above=0pt of x'] {\(x'\)};
      \node[vertex label, below=0pt of y'] {\(y'\)};
      \node[vertex label, below=0pt of z'] {\(z'\)};
      \node[vertex label, above=0pt of t1] {\(t‚ÇÅ\)};
      \node[vertex label, above=0pt of t1'] {\(t‚ÇÅ'\)};
      \node[vertex label, right=0pt of t2] {\(t‚ÇÇ\)};

    \end{tikzpicture}
  \end{center}

\end{definition}

Again, the three-vertex semi-\OR{} graph constrains at least one of its inputs
to be \ColorId1.

\begin{lemma}{}{semior3-constraint}

  Let \(x,y,z\) be boolean vertices, and let \(Œ∫\) be a proper coloring of the
  semi-\OR{} graph on \(x,y,z\).  Then it is \emph{impossible} that
  \(Œ∫(x)=Œ∫(y)=Œ∫(z)=\ColorId0\).

\end{lemma}

\begin{proof}

  Suppose towards a contradiction that \(Œ∫(x)=Œ∫(y)=Œ∫(z)=\ColorId0\).  Then
  \(x'\) and \(y'\), which neighbor \(x\) and \(y\) respectively, must be
  colored \(\ColorId1\) or \(\ColorId2\).  Since they also neighbor each other,
  they must receive different colors:
  \begin{itemize}[nosep]
    \item either \(Œ∫(x')=\ColorId1\) and \(Œ∫(y')=\ColorId2\),
    \item or \(Œ∫(x')=\ColorId2\) and \(Œ∫(y')=\ColorId1\).
  \end{itemize}
  In either case, \(t‚ÇÅ\), which neighbors both \(x'\) and \(y'\), can only be
  colored \ColorId0.  Therefore, observe that \(t‚ÇÅ\) and \(z\) both have color
  \ColorId0.

  By construction, \(t‚ÇÅ\) and \(z\) are constrained by a two-vertex semi-\OR{}
  graph.  Thus \(Œ∫(t‚ÇÅ)=Œ∫(z)=\ColorId0\) violates \cref{lem:semior2-constraint},
  a contradiction.  \qedhere

\end{proof}

We are now prepared to construct full-blown \OR{} gates.  To do so, we create
three boolean vertices \(x,y,z\); the plan is to use combinations of \NOT{}
graphs and semi-\OR{} graphs to \emph{constrain} \(x,y,z\) under the relation
\[
  z=x‚à®y,
\]
so that \(z\) corresponds to the output wire of the \OR{} gate with inputs \(x\)
and \(y\).  To do so, first observe that the condition \(z=x‚à®y\) is equivalent
to
\[
  z‚àß(x‚à®y) \quad‚à®\quad ¬¨z‚àß¬¨(x‚à®y).
\]
In other words, \(z=x‚à®y\) holds if and only if the values of \(z\) and of
\(x‚à®y\) are both \True{} or both \False.  Using DeMorgan's identities and
distributivity properties, we derive that this condition is equivalent to
\begin{align*}
  \Paren*{z‚àß(x‚à®y)}‚à®\Paren*{¬¨z‚àß¬¨(x‚à®y)}
&= \xcancel{(z‚à®¬¨z)}\Paren[\big]{(z‚à®¬¨(x‚à®y)}\Paren[\big]{(x‚à®y)‚à®¬¨z}\xcancel{\Paren*{(x‚à®y)‚à®¬¨(x‚à®y)}} \\
&= \Paren[\big]{(z‚à®(¬¨x‚àß¬¨y)}\Paren*{x‚à®y‚à®¬¨z} \\
&= (z‚à®¬¨x)(z‚à®¬¨y)(x‚à®y‚à®¬¨z).
\end{align*}
Thus \(z=x‚à®y\) holds if and only if all three of the following conditions
simultaneously hold:
\begin{itemize}[nosep]
  \item At least one of \(z\) and \(¬¨x\) is \ColorId1.
  \item At least one of \(z\) and \(¬¨y\) is \ColorId1.
  \item At least one of \(x,y\), and \(¬¨z\) is \ColorId1.
\end{itemize}
Thus we construct an \OR{} graph by using \NOT{} graphs to compute \(¬¨x,¬¨y,¬¨z\),
and then constraining them using semi-\OR{} graphs on \(z,¬¨x\); \(z,¬¨y\); and
\(x,y,¬¨z\).

\tikzset{
  %pics/fake or/.style n args={5}{code={
  %    \coordinate[vertex, #4](#2) at ($ (#1) + (0,-2em) $);
  %    \coordinate[vertex, fill=ks2](aux) at ($ (#1) + (1em,-1em) $);
  %    \coordinate[vertex](#1') at ($ (#1) + (2em,0) $);
  %    \coordinate[vertex](#2') at ($ (#1) + (2em,-2em) $);
  %    \coordinate[vertex, #5](#3) at ($ (#1) + (3em,-1em) $);
  %    \draw (#1') -- (#3) -- (#2') -- (#2) -- (aux) -- (#1) -- (#1') -- (#2');
  %}},
  pics/and or colored/.style n args={5}{code={

      \pgfmathtruncatemacro\x{#3}
      \pgfmathtruncatemacro\y{#4}
      \pgfmathtruncatemacro\z{#5}

      \pgfmathtruncatemacro\nx{not(\x)}
      \pgfmathtruncatemacro\ny{not(\y)}
      \pgfmathtruncatemacro\nz{not(\z)}

      \pgfmathtruncatemacro\t{or(\x,\y)}

      % 00: 12
      % 01: 20
      % 10: 02
      % 11: 02

      \pgfmathtruncatemacro\xx{\nx*(1+\y)}
      \pgfmathtruncatemacro\yy{2*or(\x,\ny)}

      \pgfmathtruncatemacro\tt{not(\t)*(1+\nz)}
      \pgfmathtruncatemacro\nzz{2*or(\t,\z)}

      \pgfmathtruncatemacro\nxx{\x*(1+\z)}
      \pgfmathtruncatemacro\zx{2*or(\nx,\nz)}

      \pgfmathtruncatemacro\nyy{\y*(1+\z)}
      \pgfmathtruncatemacro\zy{2*or(\ny,\nz)}


      %\pgfmathtruncatemacro\tt{2*not(\t)}
      %\pgfmathtruncatemacro\nzz{2*not(\nz)-not(\t)}




      \matrix[ampersand replacement=\&, row sep=1em/2, column sep=1em/2]{
        \coordinate[vertex, fill=ks\x](x); \&\& \coordinate[vertex, fill=ks\xx](x'); \\
        \& \coordinate[vertex, fill=ks2](axy); \&\& \coordinate[vertex, fill=ks\t](txy); \&\&
        \coordinate[vertex, fill=ks\tt](txy'); \&\&
        \coordinate[vertex, fill=ks\nx](nx); \&\& \coordinate[vertex, fill=ks\nxx](nx'); \&\&
        \coordinate[vertex, fill=ks\ny](ny); \&\& \coordinate[vertex, fill=ks\nyy](ny'); \\
        \coordinate[vertex, fill=ks\y](y); \&\& \coordinate[vertex, fill=ks\yy](y'); \&\&
        \coordinate[vertex, fill=ks2](atz); \&\& \coordinate[vertex, fill=ks1](ttz); \&\&
        \coordinate[vertex, fill=ks2](anx); \&\& \coordinate[vertex, fill=ks1](tnx); \&\&
        \coordinate[vertex, fill=ks2](any); \&\& \coordinate[vertex, fill=ks1](tny); \\
        \&\&\& \coordinate[vertex, fill=ks\nz](z); \&\& \coordinate[vertex, fill=ks\nzz](z'); \&\&
        \coordinate[vertex, fill=ks\z](nzx); \&\& \coordinate[vertex, fill=ks\zx](nzx'); \&\&
        \coordinate[vertex, fill=ks\z](nzy); \&\& \coordinate[vertex, fill=ks\zy](nzy'); \\
      };

      \draw[edge]
      (x') -- (x) -- (axy) -- (y) -- (y') -- (txy) -- (x') -- (y')
      (txy') -- (txy) -- (atz) -- (z) -- (z') -- (ttz) -- (txy') -- (z')
      foreach \i in {x,y} {
        (n\i') -- (n\i) -- (an\i) -- (nz\i) -- (nz\i') -- (tn\i) -- (n\i') -- (nz\i')
      };

      \node[above=0pt of x, vertex label]{\(#2i‚ÇÅ\)};
      \node[below=0pt of y, vertex label]{\(#2i‚ÇÇ\)};
      \node[below=0pt of z, vertex label]{\(#1o\)};
      \node[below=0pt of nzx, vertex label]{\(#2o\)};
      \node[below=0pt of nzy, vertex label]{\(#2o\)};
      \node[above=0pt of nx, vertex label]{\(#1i‚ÇÅ\)};
      \node[above=0pt of ny, vertex label]{\(#1i‚ÇÇ\)};


  }},
  pics/and or/.style 2 args={code={
      \matrix[ampersand replacement=\&, row sep=1em, column sep=1em]{
        \&\& \coordinate[vertex](x0); \&\& \coordinate[vertex](nx0); \&\&
        \coordinate[vertex](y0); \&\& \coordinate[vertex](ny0); \&\&
        \coordinate[vertex](z0); \&\& \coordinate[vertex](nz0); \\
        \&\&\& \coordinate[vertex, fill=ks2](ax); \&\&\&\&
        \coordinate[vertex, fill=ks2](ay); \&\&\&\&
        \coordinate[vertex, fill=ks2](az); \\
        \coordinate[vertex](x); \&\& \coordinate[vertex](x'); \\
        \& \coordinate[vertex, fill=ks2](axy); \&\& \coordinate[vertex](txy); \&\&
        \coordinate[vertex](txy'); \&\&
        \coordinate[vertex](nx); \&\& \coordinate[vertex](nx'); \&\&
        \coordinate[vertex](ny); \&\& \coordinate[vertex](ny'); \\
        \coordinate[vertex](y); \&\& \coordinate[vertex](y'); \&\&
        \coordinate[vertex, fill=ks2](atz); \&\& \coordinate[vertex, fill=ks1](ttz); \&\&
        \coordinate[vertex, fill=ks2](anx); \&\& \coordinate[vertex, fill=ks1](tnx); \&\&
        \coordinate[vertex, fill=ks2](any); \&\& \coordinate[vertex, fill=ks1](tny); \\
        \&\&\& \coordinate[vertex](z); \&\& \coordinate[vertex](z'); \&\&
        \coordinate[vertex](nzx); \&\& \coordinate[vertex](nzx'); \&\&
        \coordinate[vertex](nzy); \&\& \coordinate[vertex](nzy'); \\
        %\coordinate[vertex, "\(#1x\)" vertex label](x);
        %\pic{fake or={x}{y}{t}{"\(#1y\)" vertex label}{}};
        %\pic{fake or={t}{nz}{o}{"\(#2z\)" vertex label}{fill=ks1}}; \&
        %\coordinate[vertex, "\(#2x\)" vertex label](nx) at (0,-1em);
        %\pic{fake or={nx}{z}{o}{"\(#1z\)" vertex label}{fill=ks1}}; \&
        %\coordinate[vertex, "\(#2y\)" vertex label](ny) at (0,-1em);
        %\pic{fake or={ny}{z}{o}{"\(#1z\)" vertex label}{fill=ks1}}; \\
      };

      \draw[edge]
      (x') -- (x) -- (axy) -- (y) -- (y') -- (txy) -- (x') -- (y')
      (txy') -- (txy) -- (atz) -- (z) -- (z') -- (ttz) -- (txy') -- (z')
      foreach \i in {x,y} {
        (n\i') -- (n\i) -- (an\i) -- (nz\i) -- (nz\i') -- (tn\i) -- (n\i') -- (nz\i')
      };

      \foreach \i/\l in {x/i‚ÇÅ,y/i‚ÇÇ,z/o} {
        \draw[edge] (\i0) -- (a\i) -- (n\i0) -- (\i0);
        \node[above, vertex label] at (\i0.north) {\(\mathbfit\l\)};
        \node[above, vertex label] at (n\i0.north) {\(\bar\l\)};
      };

      \node[above=0pt of x, vertex label]{\(#2i‚ÇÅ\)};
      \node[below=0pt of y, vertex label]{\(#2i‚ÇÇ\)};
      \node[below=0pt of z, vertex label]{\(#1o\)};
      \node[below=0pt of nzx, vertex label]{\(#2o\)};
      \node[below=0pt of nzy, vertex label]{\(#2o\)};
      \node[above=0pt of nx, vertex label]{\(#1i‚ÇÅ\)};
      \node[above=0pt of ny, vertex label]{\(#1i‚ÇÇ\)};
  }},
  assembled and or/.pic={

    \matrix[row sep=1em, column sep=1em, ampersand replacement=\&]{
      \&\& \coordinate[vertex, draw=none](); \& \coordinate[vertex](x'); \&\& \coordinate[vertex, fill=ks2](at); \\
      \&\&\&\& \coordinate[vertex](txy); \&\& \coordinate[vertex, fill=ks1](txyn); \\
      \& \coordinate[vertex](x); \&\& \coordinate[vertex](y'); \&\&
      \coordinate[vertex](txy'); \&\& \coordinate[vertex](nz'); \\
      \coordinate[vertex, fill=ks2](axy); \&\&\&\&\&\& \coordinate[vertex, fill=ks1](tx); \&\&
      \coordinate[vertex](nz); \\
      \& \coordinate[vertex](y); \&\& \coordinate[vertex](nx); \&\& \coordinate[vertex](nx'); \&\&
      \coordinate[vertex](zx'); \&\& \coordinate[vertex, fill=ks2](az); \\
      \&\&\&\& \coordinate[vertex, fill=ks2] (ann); \&\& \coordinate[vertex, fill=ks1](ty); \&\&
      \coordinate[vertex](z); \\
      \&\&\& \coordinate[vertex](ny); \&\& \coordinate[vertex](ny'); \&\& \coordinate[vertex](zy'); \\
    };

    \draw[edge]
    (x) -- (axy) -- (y)
    (y) -- (ny)
    (nx) -- (ann) -- (ny)
    (at) -- (txy) -- (x') -- (y') -- (txy) -- (txy') -- (nz') -- (txyn) -- (txy')
    (nz) -- (z) -- (az) -- (nz) -- (nz')
    foreach \i in {x,y} {
      (n\i) -- (n\i') -- (z\i') -- (t\i) -- (n\i')
      (z) -- (z\i')
      (\i) -- (\i')
    };

    \draw[edge, over] (x) -- (nx);
  },
}

\begin{definition}{\OR{} graph}{or-graph}

  Let \(ùíä‚ÇÅ,ùíä‚ÇÇ\) be boolean vertices.  Construct an \Term{\OR{} graph} on inputs
  \(ùíä‚ÇÅ,ùíä‚ÇÇ\) as follows:
  \begin{itemize}[nosep]
    \item Introduce a new vertex \(ùíê\), the output vertex.
    \item Construct \NOT{} graphs on each of \(ùíä‚ÇÅ,ùíä‚ÇÇ,ùíê\); name their output
      vertices \(\bar i‚ÇÅ,\bar i‚ÇÇ,\bar o\), respectively.
    \item Construct two-vertex semi-\OR{} graphs on \(ùíê,\bar i‚ÇÅ\) and on
      \(ùíê,\bar i‚ÇÇ\).
    \item Construct a three-vertex semi-\OR{} graph on \(ùíä‚ÇÅ,ùíä‚ÇÇ,\bar o\).
  \end{itemize}

  A picture of this construction is shown below; for readability, some vertices
  are drawn as duplicates sharing the same label to indicate that each copy
  refers to the same vertex.
  \begin{center}
    \begin{tikzpicture}
      \pic{and or={\bar}{\mathbfit}};
    \end{tikzpicture}
  \end{center}

  \begin{aside}
    Just for fun, here's what the fully-assembled \OR{} graph looks like.  This
    isn't \emph{exactly} the same graph as the one above: some \ColorId2
    vertices have been added/elided/rearranged, but the functional structure is
    otherwise the same.

    \begin{center}
      \begin{tikzpicture}
        \pic{assembled and or};

        \node[vertex label, above=0pt of x]{\(ùíä‚ÇÅ\)};
        \node[vertex label, below=0pt of y]{\(ùíä‚ÇÇ\)};
        \node[vertex label, below=0pt of z]{\(ùíê\)};

        \node[vertex label, above=0pt of nx]{\(\bar i‚ÇÅ\)};
        \node[vertex label, below=0pt of ny]{\(\bar i‚ÇÇ\)};
        \node[vertex label, above=0pt of nz]{\(\bar o\)};



      \end{tikzpicture}

    \end{center}
  \end{aside}

\end{definition}

Finally, to construct an \AND{} graph, we leverage DeMorgan's identity to
represent \AND{} operations in terms of \NOT{} and \OR{} operations, which we
already know how to implement:
\[
  z=x‚àßy \qquad‚ü∫\qquad ¬¨z=¬¨x‚à®¬¨y.
\]
Therefore we construct an \AND{} graph simply by switching the labels \(x,y,z\)
with \(¬¨x,¬¨y,¬¨z\) in the construction of the \OR{} graph.

\begin{definition}{\AND{} graph}{and-graph}

  Let \(ùíä‚ÇÅ,ùíä‚ÇÇ\) be boolean vertices.  Construct an \Term{\AND{} graph} on inputs
  \(ùíä‚ÇÅ,ùíä‚ÇÇ\) as follows:
  \begin{itemize}[nosep]
    \item Introduce a new vertex \(ùíê\), the output vertex.
    \item Construct \NOT{} graphs on each of \(ùíä‚ÇÅ,ùíä‚ÇÇ,ùíê\); name their output
      vertices \(\bar i‚ÇÅ,\bar i‚ÇÇ,\bar o\), respectively.
    \item Construct two-vertex semi-\OR{} graphs on \(\bar o,ùíä‚ÇÅ\) and \(\bar
      o,ùíä‚ÇÇ\).
    \item Construct a three-vertex semi-\OR{} graph on \(\bar i‚ÇÅ,\bar i‚ÇÇ,ùíê\).
  \end{itemize}

  \begin{center}
    \begin{tikzpicture}
      \pic{and or={\mathbfit}{\bar}};
    \end{tikzpicture}
  \end{center}

  \begin{aside}
    Here's what the fully-assembled \AND{} graph looks like.
    \begin{center}
      \begin{tikzpicture}

        \pic{assembled and or};

        \node[vertex label, above=0pt of x]{\(\bar i‚ÇÅ\)};
        \node[vertex label, below=0pt of y]{\(\bar i‚ÇÇ\)};
        \node[vertex label, below=0pt of z]{\(\bar o\)};

        \node[vertex label, above=0pt of nx]{\(ùíä‚ÇÅ\)};
        \node[vertex label, below=0pt of ny]{\(ùíä‚ÇÇ\)};
        \node[vertex label, above=0pt of nz]{\(ùíê\)};

      \end{tikzpicture}
    \end{center}
  \end{aside}

\end{definition}

Thus we have defined graph encodings for all three logic gates.  We
summarize this discussion by proving, per \cref{def:boolean-graph}, that these
constructions actually compute the boolean operations correctly.

\begin{theorem}{}{logic-graphs}

  \begin{enumerate}[nosep]
    \item The \NOT{} graph (\cref{def:not-graph}) computes the function
      \(œï(x)=¬¨x\).
    \item The \OR{} graph (\cref{def:or-graph}) computes the function
      \(œï(x,y)=x‚à®y\).
    \item The \AND{} graph (\cref{def:and-graph}) computes the function
      \(œï(x,y)=x‚àßy\).
  \end{enumerate}

\end{theorem}

\begin{proof}

  In each case, we wish to show that for each combination of input boolean
  values, the following properties hold:
  \begin{description}
  \item[Attainability] There exists a proper total coloring \(Œ∫\) of the graph
    such that \(Œ∫\) assigns those values to the input vertices.
  \item[Consistency] Every coloring under this input combination assigns the
    correct boolean value to the output vertex.
  \end{description}

  We prove each part separately.
  \begin{enumerate}

    \item Let \(ùíä\) be the input vertex and \(ùíê\) be the output vertex of a
      \NOT{} graph.

      \begin{description}
      \item[Attainability] Both input settings are attained by some proper
        coloring:

        \begin{center}
          \begin{tikzpicture}
            \matrix[row sep=1em, column sep=1em, matrix of nodes]{ |[vertex,
              fill=ks0](i0)| && |[vertex, fill=ks1](o0)| &[3em] |[vertex,
              fill=ks1](i1)| && |[vertex, fill=ks0](o1)| \\
              & |[vertex, fill=ks2](a0)| &&& |[vertex, fill=ks2](a1)| \\
            };

            \draw[edge] foreach \i in {0,1} { (i\i) -- (o\i) -- (a\i) -- (i\i) };
            \foreach \i in {0,1} {
              \pgfmathtruncatemacro\ni{1-\i}
              \node[above=0pt of i\i]{\(ùíä‚Ü¶\ColorId\i\)};
              \node[above=0pt of o\i]{\(ùíê‚Ü¶\ColorId\ni\)};
            }
          \end{tikzpicture}
        \end{center}

      \item[Consistency] We claim that the colorings shown above are the only
        possible proper colorings (and therefore all proper colorings assign the
        same output values).  This is straightforward to see.  Since \(ùíä\) and
        \(ùíê\) are both boolean vertices (they are connected to a \ColorId2),
        they can only take colors in \(\Set{\ColorId0,\ColorId1}\).  Then, since
        \(ùíä\) and \(ùíê\) are joined to each other by an edge, their colors must
        be opposite, so for every proper coloring \(Œ∫\), we have \(Œ∫(ùíê)=¬¨Œ∫(ùíä)\),
        as desired.

      \end{description}

      Thus the \NOT{} graph indeed computes \(œï(x)=¬¨x\).

    \item Let \(ùíä‚ÇÅ,ùíä‚ÇÇ,ùíê\) be boolean vertices such that \(ùíê\) is the output
      vertex of an \OR{} graph on input vertices \(ùíä‚ÇÅ\) and \(ùíä‚ÇÇ\).

      \begin{description}
      \item[Attainability] As shown in the diagrams below, each input
        combination is properly attainable (this time, the colorings for each
        combination are not necessarily unique).  In each diagram, the
        \NOT-graphs joining \(x/¬¨x\), \(y/¬¨y\), and \(z/¬¨z\) have been omitted
        to avoid visual cluttering; assume that they are implicitly present.

        \tikzset{every picture/.style={baseline=(current bounding box.center)}}

        \[
          \begin{array}{cc|c|c}
            ùíä‚ÇÅ‚Ü¶x‚ÇÅ & ùíä‚ÇÇ‚Ü¶x‚ÇÇ & ùíê‚Ü¶x‚ÇÅ‚à®x‚ÇÇ & \text{coloring} \\ \midrule
            \False & \False & \False & \tikz{\pic{and or colored={\bar}{\mathbfit}{0}{0}{0}}} \\
            \False & \True & \True & \tikz{\pic{and or colored={\bar}{\mathbfit}{0}{1}{1}}} \\
            \True & \False & \True & \tikz{\pic{and or colored={\bar}{\mathbfit}{1}{0}{1}}} \\
            \True & \True & \True & \tikz{\pic{and or colored={\bar}{\mathbfit}{1}{1}{1}}}
          \end{array}
        \]

      \item[Consistency] Let \(Œ∫\) be an arbitrary proper coloring of the \OR{}
        graph.  We wish to show that \(Œ∫(ùíê)=Œ∫(ùíä‚ÇÅ)‚à®Œ∫(ùíä‚ÇÇ)\) always holds.  In
        other words, we will argue that \(Œ∫(ùíê)=\True\) if and only if at least
        one of \(Œ∫(ùíä‚ÇÅ),Œ∫(ùíä‚ÇÇ)\) is \True.

        \begin{ifflist}

        \item Suppose that \(Œ∫(ùíê)=\True\).  Then consistency of the \NOT{} graph
          implies that \(Œ∫(\bar o)=\False\).  By construction of the \OR{}
          graph, the vertices \(ùíä‚ÇÅ,ùíä‚ÇÇ,\bar o\) are constrained by a three-vertex
          semi-\OR, which necessitates that at least one of \(ùíä‚ÇÅ,ùíä‚ÇÇ,\bar o\) is
          colored \True. Since \(\bar o\) isn't, that means at least one of
          \(ùíä‚ÇÅ,ùíä‚ÇÇ\) must be colored \True, as desired.

        \item Suppose that at least one of \(ùíä‚ÇÅ,ùíä‚ÇÇ\) is colored \True; assume
          without loss of generality that \(Œ∫(ùíä‚ÇÅ)=\True\).  Consistency of the
          \NOT{} graph implies \(Œ∫(\bar i‚ÇÅ)=\False\).  There is a two-vertex
          semi-\OR{} constraining \(\bar i‚ÇÅ\) and \(ùíê\), so at least one of them
          must be colored \True; \(\bar i‚ÇÅ\) isn't, leaving \(Œ∫(ùíê)=\True\), as
          desired.

        \end{ifflist}

      \end{description}

    \item Let \(ùíä‚ÇÅ,ùíä‚ÇÇ,ùíê\) be boolean vertices such that \(ùíê\) is the output
      vertex of an \AND{} graph on input vertices \(ùíä‚ÇÅ\) and \(ùíä‚ÇÇ\).

      \begin{description}
      \item[Attainability] Each input combination is attainable, per the
        diagrams below (again, not necessarily unique):

        \tikzset{every picture/.style={baseline=(current bounding box.center)}}

        \[
          \begin{array}{cc|c|c}
            ùíä‚ÇÅ‚Ü¶x‚ÇÅ & ùíä‚ÇÇ‚Ü¶x‚ÇÇ & ùíê‚Ü¶x‚ÇÅ‚àßx‚ÇÇ & \text{coloring} \\ \midrule
            \False & \False & \False & \tikz{\pic{and or colored={\mathbfit}{\bar}{0}{0}{1}}} \\
            \False & \True & \False & \tikz{\pic{and or colored={\mathbfit}{\bar}{0}{1}{1}}} \\
            \True & \False & \False & \tikz{\pic{and or colored={\mathbfit}{\bar}{1}{0}{1}}} \\
            \True & \True & \True & \tikz{\pic{and or colored={\mathbfit}{\bar}{1}{1}{0}}}
          \end{array}
        \]

      \item[Consistency] Note that the \AND{} graph is constructed by swapping
        each boolean vertex \(ùíä‚ÇÅ,ùíä‚ÇÇ,ùíê\) with its negation \(¬¨ùíä‚ÇÅ,¬¨ùíä‚ÇÇ,¬¨ùíê\),
        respectively.  Thus consistency of the \AND{} graph follows from
        consistency of the \OR{} graph (proven above) and DeMorgan's identities:
        for any proper coloring \(Œ∫\),
        \[
          Œ∫(\bar o)=Œ∫(\bar i‚ÇÅ)‚à®Œ∫(\bar i‚ÇÇ)
          ‚ü∫ ¬¨Œ∫(ùíê)=¬¨Œ∫(ùíä‚ÇÅ)‚à®¬¨Œ∫(ùíä‚ÇÇ)
          ‚ü∫ Œ∫(ùíê)=Œ∫(ùíä‚ÇÅ)‚àßŒ∫(ùíä‚ÇÇ).  \qedhere
        \]

      \end{description}

  \end{enumerate}

\end{proof}



%We summarize this discussion by proving that the \NOT, \OR{}, and \AND{} graphs
%actually compute their corresponding logic gates.
%
%\begin{theorem}{\NOT, \OR, \AND{} graphs compute their logic gates}{logic-graphs}
%
%  \begin{itemize}[nosep]
%    \item The \NOT{} graph on input \(x\) 
%  \end{itemize}
%  
%  
%\end{theorem}

Finally, any circuit can now be converted to a boolean 3-coloring graph
computing it, by converting each gate in the circuit to its corresponding graph.
We define this construction exactly below.

\begin{definition}{boolean graph of a circuit}{circuit-to-graph}

  Let \(C\) be a boolean circuit.  The \Term{boolean graph of \(C\)}, denoted
  \(Œì_C\), is constructed as follows:
  \begin{itemize}
    \item For each wire \(w\) in \(C\), construct a corresponding boolean vertex
      \(v_w\).

      If \(w\) is an input wire of \(C\), then label \(v_w\) an input vertex of
      \(Œì_C\).  Similarly, if \(w\) is the output wire, then label \(v_w\) the
      output vertex of \(Œì_C\).
    \item For each \NOT{} gate with input wire \(w‚ÇÅ\) and output wire \(w‚ÇÇ\),
      construct a \NOT{} graph (\cref{def:not-graph}) on input vertex \(v_{w‚ÇÅ}\)
      and output vertex \(v_{w‚ÇÇ}\).
    \item For each \AND/\OR{} gate with input wires \(w‚ÇÅ,w‚ÇÇ\) and output wire
      \(w‚ÇÉ\), construct a corresponding \AND/\OR{} graph
      (\cref{def:and-graph,def:or-graph}) on input vertices \(v_{w‚ÇÅ},v_{w‚ÇÇ}\)
      and output vertex \(v_{w‚ÇÉ}\).
  \end{itemize}
  For each logic gate \(g\) in \(C\), let \(Œì_g\) denote its corresponding
  subgraph in \(Œì_C\).

\end{definition}

First, observe that this definition directly describes an algorithm that takes a
circuit \(C\) and returns its boolean graph \(Œì_C\).  This algorithm runs in
polynomial-time, because constructing each subgraph ``component'' (boolean
vertices, logic-gate subgraphs) incurs a constant amount of work (plus some
polynomial-time bookkeeping), and the total number of component-construction
iterations is bounded by the size of \(C\) itself.

Next, we prove that \(Œì_C\) correctly computes \(C\); this result follows
straightforwardly from correctness of each logic-gate subgraph
(\cref{th:logic-graphs}).

\begin{theorem}{}{gc-computes-c}

  Let \(C\) be a boolean circuit, and let \(Œì_C\) be the boolean graph of \(C\)
  (\cref{def:circuit-to-graph}).  Then \(Œì\) \emph{computes}
  (\cref{def:boolean-graph}) \(C\).

\end{theorem}

\begin{proof}

  Assume that the input wires of \(C\) are \(w‚ÇÅ^*,\dotsc,w‚Çô^*\), and that the
  corresponding boolean vertices in \(Œì_C\) are \(ùíä‚±º=v_{w‚±º^*}\) for each
  \(j=1,\dotsc,n\).

  We wish to show that any input combination \(X‚àà\TF[n]\) is attainable by some
  proper coloring on \(Œì_C\), and that all proper colorings generate outputs
  consistent with \(C\).

  \begin{description}
  \item[Attainability] Let \(X‚àà\TF[n]\) be arbitrary. We describe a procedure to
    construct a proper coloring on \(Œì_C\) attaining \(X\) on the input
    vertices.

    Initially, for each wire \(w\) in \(C\), its boolean vertex \(v_w\) is
    uncolored; correspondingly, mark \(w\) as ``unvisited''.  Start by assigning
    \(X\), as colors, to the input vertices \(ùíä‚ÇÅ,\dotsc,ùíä‚Çô\), and
    correspondingly mark each input wire \(w‚ÇÅ^*,\dotsc,w‚Çô^*\) as ``visited''.

    Next, as long as there remain unvisited wires in \(C\), repeatedly color
    logic-gate subgraphs in \(Œì\) as follows. \(C\) contains no cyclic
    dependencies, so there must exist at least one gate \(g\) with
    already-visited input wire(s) \(w·µ¢\) and unvisited output wire \(w'\). Then
    the corresponding vertex/vertices \(v_{w·µ¢}\) is/are colored, while
    \(v_{w'}\) remains uncolored.  By consistency of each logic-gate subgraph
    (\cref{th:logic-graphs}), there exists a proper coloring of \(Œì_g\)
    extending the pre-existing coloring on \(v_{w·µ¢}\); assign those colors to
    \(Œì_g\), and mark the wire \(w'\) as visited.  This assignment preserves
    properness of the partial coloring because, by construction of \(Œì_C\),
    there are never any edges joining the internal or output vertices across
    different logic-gate subgraphs, so we may freely color \(Œì_g\) without
    worrying about introducing improper edges with neighbors \emph{outside}
    \(Œì_g\).  By induction on the number of visited wires, this procedure
    preserves properness at each iteration, thereby resulting in a proper total
    coloring of \(Œì_C\).

  \item[Consistency] Consistency of each logic-gate subgraph
    (\cref{th:logic-graphs}) implies that the boolean relations at each logic
    gate in \(C\) are exactly matched by the boolean colorings at each
    logic-gate subgraph in \(Œì_C\).  Thus by induction on the structure of
    \(C\), the output vertex in \(Œì_C\) must always have the same boolean value
    as the output wire in \(C\).  \qedhere

  \end{description}

\end{proof}

The takeaway here, intuitively, is that 3-coloring graphs are as computationally
powerful as circuits are.  If any algorithm can be encoded as a sequence of
circuit computations, and circuits can be embedded in graph 3-colorings, then
effectively, any algorithm is essentially a graph 3-coloring computation‚Äîwith
data stored as colors, and logic being carried out by properness constraints.
Therefore, we would be unsurprised to find, as we discuss in the next
subsection, that every circuit game is also just a graph 3-coloring game, under
the appropriate translations of terminology/game-rules.

%Finally, we are now equipped to discuss the complexity of graph-coloring
%\emph{games}

%\begin{theorem}{}{circuit-to-graph}%
%  For any boolean circuit \(C\), there exists a boolean graph that computes
%  [the function defined by] \(C\).  Moreover, there exists a polynomial-time
%  algorithm that performs this conversion from boolean circuits to graphs.
%\end{theorem}
%
%\begin{proof}
%  We describe an algorithm that, given a circuit \(C\), generates a boolean
%  graph computing \(C\).
%
%  First, construct the special triangle \(s_\True,s_\False,s_\Aux\).
%
%  For each wire in \(C\) (including the input and output wires), create a
%  corresponding vertex and join it by an edge to \(s_\Aux\). (The color of this
%  vertex will correspond to the value carried by the wire.)
%
%  Next, for each [\NOT, \OR, and \AND] gate \(g\) in \(C\), apply
%  \cref{lem:boolean-operation-graphs} to construct a subgraph \(Œ≥\) computing
%  \(g\).  The input vertices of \(Œ≥\) should exactly correspond to the input
%  wires of \(g\), and the output vertex of \(Œ≥\) should correspond to the
%  output wire of \(g\).
%
%  %\todo{not done, need some induction to make precise}
%
%\end{proof}
%






%suppose we assign to vertex
%\(x\) the color \ColorId0.  Then \(x'\) is adjacent to a \ColorId0 (\(x\)) and a
%\ColorId1 (rightmost vertex), so \(x'\) can only be colored \ColorId2. 
%Consequently, \(y'\) neighbors a \ColorId2 (\(x'\)) and a \ColorId1 (rightmost),
%so \(y'\) must be colored \ColorId0.  Finally, that means \(y\) neighbors a
%\ColorId0 (\(y'\)) and a \ColorId2 (``middle'' vertex), so \(y\) must be \ColorId1.






%\begin{lemma}{\NOT, \OR, and \AND{} graphs}{boolean-operation-graphs}%
%  There exist graphs computing each of the basic boolean operations \NOT, \OR,
%  and \AND.
%\end{lemma}
%
%\begin{proof}
%
%  \tikzset{
%    boolean graph/.style={x=3em, y=3em},
%    over/.style={
%      preaction={draw=white, line width=3pt},
%    },
%    triangle/.pic={
%      \draw (0,0) -- (0,-1) -- (1,0) -- cycle
%      (0,0) coordinate[vertex, fill=ks-true] node[left]{\(s_\True\)}
%      (1,0) coordinate[vertex, fill=ks-false] node[right]{\(s_\False\)}
%      (0,-1) coordinate[vertex, fill=ks-aux] node[left]{\(s_\Aux\)};
%    },
%    semi-or graph/.pic={
%      \coordinate[vertex](i1);
%      \coordinate[vertex](i2) at (0,-1);
%      \coordinate[vertex](i1') at (1,0);
%      \coordinate[vertex](i2') at (1,-1);
%      \coordinate[vertex](t) at (2,0);
%      \coordinate[vertex](a) at (0,-1/2);
%
%      \node[vertex label, left] at (i1){\(i_1\)};
%      \node[vertex label, left] at (i2){\(i_2\)};
%      \node[vertex label, left] at (a){\(s_\Aux\)};
%      \node[vertex label, right] at (t){\(s_\True\)};
%
%      \draw (i2') -- (i2) -- (a) -- (i1) -- (i1') -- (t) -- (i2') -- (i1');
%    },
%    and-or graph/.pic={
%      \coordinate[vertex](i1) at (-1,-1);
%      \coordinate[vertex](ai) at (0,-3/2);
%      \coordinate[vertex](i2) at (-1,-2);
%
%      \coordinate[vertex](i1') at (1,1);
%      \coordinate[vertex](i2') at (1,0);
%
%      \coordinate[vertex](i') at (2,1);
%      \coordinate[vertex](a') at (2,0);
%
%      \coordinate[vertex](n1) at (1,-1);
%      %\coordinate[vertex](an) at (1,-3/2);
%      \coordinate[vertex](n2) at (1,-2);
%
%      \coordinate[vertex](no) at (5,1);
%      \coordinate[vertex](o) at (6,0);
%      \coordinate[vertex](ao) at (6,1);
%
%      \coordinate[vertex](i'') at (3,1);
%      \coordinate[vertex](n1') at (2,-1);
%      \coordinate[vertex](n2') at (2,-2);
%
%      \coordinate[vertex](no') at (4,1);
%      \coordinate[vertex](o1') at (4,-1);
%      \coordinate[vertex](o2') at (4,-2);
%
%      \coordinate[vertex](to) at (3,0);
%      \coordinate[vertex](ti) at (3,-3/2);
%
%      \node[vertex label, below] at (ai) {\(s_\Aux\)};
%      \node[vertex label, below] at (a') {\(s_\Aux\)};
%
%      \node[vertex label, below] at (to) {\(s_\True\)};
%      \node[vertex label, below] at (ti) {\(s_\True\)};
%
%      \node[vertex label, above] at (ao) {\(s_\Aux\)};
%
%      \node[vertex label, above] at (i') {\(i'\)};
%
%
%      \draw
%      (i1) -- (ai) -- (i2) (n1) -- (ai) -- (n2)
%      (i1) -- (n1) -- (n1') -- (o1') -- (o) (n1') -- (ti) -- (o1')
%      (i2) -- (n2) -- (n2') -- (o2') -- (o) (n2') -- (ti) -- (o2')
%      %(n1) -- (an) -- (n2)
%      (o) -- (no) -- (ao) -- (o)
%      (i1) -- (i1') -- (i2') -- (i') -- (i1')
%      (a') -- (i') -- (i'') -- (no') -- (no) (no') -- (to) -- (i'');
%
%      \draw[over] (i2) -- (i2');
%
%
%    },
%    or graph/.pic={
%
%      \pic{and-or graph};
%      \node[vertex label, left] at (i1) {\(i‚ÇÅ\)};
%      \node[vertex label, left] at (i2) {\(i‚ÇÇ\)};
%      \node[vertex label, below] at (n1) {\(¬¨i‚ÇÅ\)};
%      \node[vertex label, below] at (n2) {\(¬¨i‚ÇÇ\)};
%      \node[vertex label, right] at (o) {\(o\)};
%      \node[vertex label, above] at (no) {\(¬¨o\)};
%
%    },
%    and graph/.pic={
%
%      \pic{and-or graph};
%      \node[vertex label, left] at (i1) {\(¬¨i‚ÇÅ\)};
%      \node[vertex label, left] at (i2) {\(¬¨i‚ÇÇ\)};
%      \node[vertex label, below] at (n1) {\(i‚ÇÅ\)};
%      \node[vertex label, below] at (n2) {\(i‚ÇÇ\)};
%      \node[vertex label, right] at (o) {\(¬¨o\)};
%      \node[vertex label, above] at (no) {\(o\)};
%
%    },
%    not graph/.pic={
%      \coordinate[vertex](i);
%      \coordinate[vertex](o) at (1,0);
%      \coordinate[vertex](a) at (0,-1);
%
%      \node[vertex label, left] at (a) {\(s_\Aux\)};
%      \node[vertex label, left] at (i) {\(i‚ÇÅ\)};
%      \node[vertex label, right] at (o) {\(o\)};
%      \draw (i) -- (o) -- (a) -- (i);
%    },
%  }
%
%  We demonstrate constructions of graphs computing each of the boolean
%  operations.
%
%  To improve readability, we adopt the following conventions in the
%  illustrations below:
%  \begin{itemize}
%    \item Assume implicitly the presence of special vertices
%      \(s_\True,s_\False,s_\Aux\) joined by a triangle.  We omit them from the
%      diagrams, using them only when needed.
%    \item To avoid excessive edge crossings, we sometimes illustrate one vertex
%      as multiple ``duplicate'' vertices with the same label.
%  \end{itemize}
%
%  \begin{description}
%
%  \item[\NOT] The following graph computes the boolean \NOT{} operation:
%
%    \begin{center}
%      \begin{tikzpicture}[boolean graph]
%        \pic{not graph};
%      \end{tikzpicture}
%    \end{center}
%
%    Since \(i‚ÇÅ\) neighbors \(o\) (and both neighbor \(s_\Aux\)), they
%    necessarily have opposite colors.  Below we show colorings for both
%    possible input values (unique up to permutation of colors):
%
%    \[
%      \begin{array}{c|c}
%        x‚ÇÅ=\True & x‚ÇÅ=\False \\ \midrule
%        \begin{tikzpicture}[boolean graph]
%          \pic{not graph};
%          \coordinate[vertex, fill=ks-true]() at (i);
%          \coordinate[vertex, fill=ks-false]() at (o);
%          \coordinate[vertex, fill=ks-aux]() at (a);
%
%          \pic at (3,0) {triangle};
%        \end{tikzpicture}
%        &
%        \begin{tikzpicture}[boolean graph]
%          \pic{not graph};
%          \coordinate[vertex, fill=ks-false]() at (i);
%          \coordinate[vertex, fill=ks-true]() at (o);
%          \coordinate[vertex, fill=ks-aux]() at (a);
%
%          \pic at (3,0) {triangle};
%        \end{tikzpicture}
%      \end{array}
%    \]
%
%  \item[\OR] Our construction of the boolean \OR{} gate is slightly
%    complicated.  To that end, before giving that construction, we first
%    introduce a \emph{helper} graph, which we call the ``semi-\OR'' graph.
%
%    \begin{aside}
%
%      \begin{center}
%        \begin{tikzpicture}[boolean graph]
%          \pic{semi-or graph};
%        \end{tikzpicture}
%      \end{center}
%
%      Notice that this graph does not yet define a boolean graph, because it has
%      no output vertex.  However, it has some useful properties resembling that
%      of an \OR-gate.  Examine each of the possible input combinations:
%      \begin{itemize}
%        \item When \(i_1\) and \(i_2\) are both assigned \True, a proper
%          coloring exists:
%          \begin{center}
%            \begin{tikzpicture}[boolean graph]
%              \pic{semi-or graph};
%              \coordinate[vertex, fill=ks-true]() at (i1);
%              \coordinate[vertex, fill=ks-true]() at (i2);
%              \coordinate[vertex, fill=ks-false]() at (i1');
%              \coordinate[vertex, fill=ks-aux]() at (i2');
%              \coordinate[vertex, fill=ks-aux]() at (a);
%              \coordinate[vertex, fill=ks-true]() at (t);
%
%              \pic at (4,0){triangle};
%            \end{tikzpicture}
%          \end{center}
%
%        \item When \(i_1\) and \(i_2\) are both assigned \False, then no proper
%          coloring exists:
%          \begin{center}
%            \begin{tikzpicture}[boolean graph]
%              \pic{semi-or graph};
%              \coordinate[vertex, fill=ks-false]() at (i1);
%              \coordinate[vertex, fill=ks-false]() at (i2);
%              %\coordinate[vertex, fill=ks-false]() at (i1');
%              %\coordinate[vertex, fill=ks-aux]() at (i2');
%              \coordinate[vertex, fill=ks-aux]() at (a);
%              \coordinate[vertex, fill=ks-true]() at (t);
%              %\node[above] at (i1') {\(i‚ÇÅ'\)};
%              %\node[below] at (i2') {\(i‚ÇÇ'\)};
%
%              \pic at (4,0) {triangle};
%            \end{tikzpicture}
%          \end{center}
%
%          Each of the two uncolored vertices neighbor \(s_\True\) and an input
%          vertex \(i‚ÇÅ\) or \(i‚ÇÇ\), whose color matches \(s_\False\).  Thus the
%          uncolored vertices would have to be colored same as \(s_\Aux\).
%          However, they neighbor each other as well, forcing them to share a
%          color.  Thus there is no proper coloring.
%
%        \item When exactly one of \(i_1,i_2\) is assigned \True{} and the other
%          \False, then a proper coloring exists:
%          \begin{center}
%            \begin{tikzpicture}[boolean graph]
%              \pic{semi-or graph};
%              \coordinate[vertex, fill=ks-true]() at (i1);
%              \coordinate[vertex, fill=ks-false]() at (i2);
%              \coordinate[vertex, fill=ks-false]() at (i1');
%              \coordinate[vertex, fill=ks-aux]() at (i2');
%              \coordinate[vertex, fill=ks-aux]() at (a);
%              \coordinate[vertex, fill=ks-true]() at (t);
%            \end{tikzpicture}
%          \end{center}
%
%    \end{itemize}
%    Together, these observations reveal that the semi-\OR{} graph does not
%    \emph{compute} the \OR{} operation, but it has the property of being
%    \emph{properly-3-colorable} if and only if \(i_1\) or \(i_2\) is assigned
%    \True.
%
%
%  \end{aside}
%
%  Now, we are ready to construct a (``full'') \OR{} graph:
%
%  \begin{center}
%    \begin{tikzpicture}[boolean graph]
%      \pic{or graph};
%    \end{tikzpicture}
%  \end{center}
%
%  %\todo[inline]{i made two versions of this graph diagram---the above has less
%  %  vertex duplication and is laid out more like a ``gate'', but the below
%  %  graph more explicitly/clearly illustrates the parts and may be easier to
%  %  explain, at the expense of many more duplicated vertices. @nick, do you
%  %find one nicer than the other?}
%
%  \begin{center}
%    \begin{tikzpicture}[boolean graph]
%
%      \coordinate[vertex](i1);
%      \coordinate[vertex](i2) at (0,-1);
%      \coordinate[vertex](a) at (0,-1/2);
%      \coordinate[vertex](i') at (2,0);
%      \coordinate[vertex](a') at (2,-1/2);
%      \coordinate[vertex](no') at (2,-1);
%      \coordinate[vertex](no'') at (3,-1);
%      \coordinate[vertex](i'') at (3,0);
%      \coordinate[vertex](to) at (4,0);
%
%      \coordinate[vertex](in1) at (0,-2);
%      \coordinate[vertex](in2) at (0,-4);
%
%      \coordinate[vertex](on) at (0,-6);
%      \coordinate[vertex](no) at (1,-6);
%      \coordinate[vertex](ao) at (0,-7);
%
%
%      \foreach \i in {1,2} {
%        \coordinate[vertex](i\i') at ($ (i\i) + (1,0) $);
%        \node[vertex label, left] at (i\i) {\(i_{\i}\)};
%        \node[vertex label, left] at (in\i) {\(i_{\i}\)};
%
%        \coordinate[vertex](n\i) at ($ (in\i) + (1,0) $);
%        \coordinate[vertex](a\i) at ($ (in\i) + (0,-1) $);
%        \coordinate[vertex](n\i') at ($ (n\i) + (1,0) $);
%        \coordinate[vertex](an\i) at ($ (n\i) + (0,-1/2) $);
%        \coordinate[vertex](o\i) at ($ (n\i) + (0,-1) $);
%        \coordinate[vertex](o\i') at ($ (o\i) + (1,0) $);
%        \coordinate[vertex](t\i) at ($ (n\i') + (1,0) $);
%
%        \node[vertex label, above] at (n\i) {\(¬¨i_{\i}\)};
%        \node[vertex label, left] at (o\i) {\(o\)};
%        \node[vertex label, right] at (an\i) {\(s_\Aux\)};
%        \node[vertex label, right] at (t\i) {\(s_\True\)};
%
%        \draw
%          (in\i) -- (n\i) -- (a\i) -- (in\i)
%          (n\i) -- (an\i) -- (o\i) -- (o\i') -- (n\i') -- (n\i)
%          (n\i') -- (t\i) -- (o\i');
%      }
%
%      \foreach \v in {a,a1,a2,ao} {
%        \node[vertex label, left] at (\v) {\(s_\Aux\)};
%      }
%      \node[vertex label, right] at (a') {\(s_\Aux\)};
%
%      \node[vertex label, above] at (i') {\(i'\)};
%      \node[vertex label, left] at (on) {\(o\)};
%      \node[vertex label, left] at (no') {\(¬¨o\)};
%      \node[vertex label, right] at (no) {\(¬¨o\)};
%
%      \node[vertex label, right] at (to) {\(s_\True\)};
%
%      \draw
%        (i1) -- (a) -- (i2) -- (i2') -- (i1') -- (i1)
%        (i1') -- (i') -- (i2')
%        (i') -- (a') -- (no') -- (no'') -- (i'') -- (i')
%        (i'') -- (to) -- (no'')
%        (on) -- (no) -- (ao) -- (on);
%
%    \end{tikzpicture}
%  \end{center}
%
%  To see why this construction works,
%
%  %\todo{still not done}
%
%
%
%
%\item[\AND] To construct an \AND{} gate, we apply DeMorgan's law to rewrite
%  \AND{} in terms of \NOT{} and \OR:
%  \[
%    y=x‚ÇÅ‚àßx‚ÇÇ ‚ü∫ ¬¨y=¬¨x‚ÇÅ‚à®¬¨x‚ÇÇ.
%  \]
%
%  To that end, we implement an \AND{} graph by negating both the input
%  vertices and the output vertex in the \OR{} graph.  We do so by swapping
%  vertices
%  \[
%    i‚ÇÅ‚Üî¬¨i‚ÇÅ, \qquad i‚ÇÇ‚Üî¬¨i‚ÇÇ, \qquad o‚Üî¬¨o
%  \]
%  in the \OR{} graph construction:
%
%  \begin{center}
%    \begin{tikzpicture}[boolean graph]
%      \pic{and graph};
%    \end{tikzpicture}
%  \end{center}
%
%
%\end{description}
%
%\end{proof}
%
%\begin{theorem}{}{circuit-to-graph}%
%  For any boolean circuit \(C\), there exists a boolean graph that computes
%  [the function defined by] \(C\).  Moreover, there exists a polynomial-time
%  algorithm that performs this conversion from boolean circuits to graphs.
%\end{theorem}
%
%\begin{proof}
%  We describe an algorithm that, given a circuit \(C\), generates a boolean
%  graph computing \(C\).
%
%  First, construct the special triangle \(s_\True,s_\False,s_\Aux\).
%
%  For each wire in \(C\) (including the input and output wires), create a
%  corresponding vertex and join it by an edge to \(s_\Aux\). (The color of this
%  vertex will correspond to the value carried by the wire.)
%
%  Next, for each [\NOT, \OR, and \AND] gate \(g\) in \(C\), apply
%  \cref{lem:boolean-operation-graphs} to construct a subgraph \(Œ≥\) computing
%  \(g\).  The input vertices of \(Œ≥\) should exactly correspond to the input
%  wires of \(g\), and the output vertex of \(Œ≥\) should correspond to the
%  output wire of \(g\).
%
%  %\todo{not done, need some induction to make precise}
%
%\end{proof}
%
%%\begin{example}{}{}
%%  Conversion of an example circuit (e.g., XOR gate?  or something simpler, like
%%  \(x‚ÇÅ‚àß¬¨x‚ÇÇ\)) to graph.
%%
%%  TODO
%%\end{example}

\subsection{Translating \Problem{Circuit Satisfiability} games to \Problem{3-Colorability} games}

Recall that in a \CircSat[k] game, two players alternate turns assigning inputs
to a circuit, with victory decided by the final output of the circuit: \True{}
means the first player wins; \False{} means the second player wins. We now wish
to encode these objectives in the language of 3-colorings and properness.

To start with, we are given a circuit \(C\), with inputs partitioned into \(k\)
groups, \(I‚ÇÅ,\dotsc,I‚Çñ\).  Naturally, we start by converting \(C\) to a boolean
graph \(Œì_C\), mapping the groups of circuit inputs directly to groups of
vertices,
\[
  U·µ¢=\SetBuilder{v_w}{w‚ààI·µ¢}
\]
for \(i‚àà\Set{1,2,\dotsc,k}\).  So far, this doesn't define a valid \Col[k] game
yet, as \(U‚ÇÅ,\dotsc,U‚Çñ\) don't partition all vertices in \(Œì_C\)‚Äîthe uncolored
internal vertices are unaccounted for.

In choosing who colors the remaining vertices, we wish to ensure that, whatever
coloring gets assigned to the internals of \(Œì_C\), it should be consistent with
the wire values in \(C\), so that \cref{th:gc-computes-c} applies.  The easiest
way to do so is to wait until all \emph{input} vertices have been colored before
coloring the internal vertices.  To this end, we place all internal vertices in
the last group, \(U‚Çñ\).  Of course, in the special case that \(k=0\), there are
no turns to be played, so we include the full coloring of the graph (computable
by simply evaluating the circuit and filling in the proper colorings at each
gate, per \cref{th:logic-graphs}) in the pre-coloring.

Finally, we translate the winning condition as follows.  In \CircSat[k], the
winning condition is that the \emph{first} player wins if and only if the final
output is \True.  Meanwhile, in \Col[k], the winning condition is that the
\emph{last} player wins if and only if all turns finish, resulting in a proper
total coloring.  The asymmetry between \CircSat[k] and \Col[k] is the difference
in who wins according to the parity of the number of turns:
\begin{itemize}

  \item The first player plays on odd-numbered turns, so when \(k\) is odd, the
    first player is the last player.  Thus for odd \(k\) the winning incentive
    of the first player in \CircSat[k], should exactly match that of the last
    player in \(\Col[k]\): a proper total coloring should be obtained if and
    only if the circuit finally outputs \True.

  \item When \(k\) is even, the second player is the last player.  Thus for even
    \(k\) the winning incentive of the first player should be opposite that of
    the last player: the final coloring is proper if and only if the circuit
    outputs \False.

\end{itemize}
In all cases, we enforce the winning condition in all cases by appending \(k\)
\NOT-graphs to the output vertex of the graph and pre-coloring the \emph{final}
output vertex to \False.


We summarize this \emph{reduction} from \CircSat[k] to \Col[k], including the
steps of the circuit-to-graph conversion (\cref{def:circuit-to-graph}), in the
algorithm below.

\begin{algorithm}{reduction from \CircSat[k] to \Col[k]}{circsat-to-3col}
  \begin{algorithmic}
    \Given{a circuit \(C\) with inputs partitioned as \(I‚ÇÅ‚äî\dotsb‚äîI‚Çñ\)}
    \LComment{construct the boolean graph of \(C\)}
    \State{create a blank graph \(Œì\) and partial-coloring \(Œ∫\)}
    \State{introduce (in \(Œì\)) a special vertex \(v_{\mathbf 2}\)}
    \State{pre-color \(Œ∫(v_{\mathbf 2})=\ColorId2\)}
    \ForEach{wire \(w\) in \(C\)}
    \State{introduce a vertex \(v_w\)}
    \State{introduce an edge \(v_w‚Üîv_{\mathbf 2}\)}
    \EndFor
    \ForEach{logic gate \(g\) in \(C\)}
    \If{\(g\) is a \NOT{} gate with input wire \(w‚ÇÅ\) and output wire \(w‚ÇÇ\)}
    \State{add to \(Œì\) a \NOT{} graph on input \(v_{w‚ÇÅ}\) and output \(v_{w‚ÇÇ}\), following \cref{def:not-graph}}
    \ElsIf{\(g\) is an \AND{} gate with inputs \(w‚ÇÅ,w‚ÇÇ\) and output \(w‚ÇÇ\)}
    \State{add to \(Œì\) an \AND{} graph on inputs \(v_{w‚ÇÅ},v_{w‚ÇÇ}\) and output \(v_{w‚ÇÉ}\), per \cref{def:and-graph}}
    \ElsIf{\(g\) is an \OR{} gate with inputs \(w‚ÇÅ,w‚ÇÇ\) and output \(w‚ÇÇ\)}
    \State{add to \(Œì\) an \OR{} graph on inputs \(v_{w‚ÇÅ},v_{w‚ÇÇ}\) and output \(v_{w‚ÇÉ}\), per \cref{def:or-graph}}
    \EndIf
    \EndFor
    \If{\(k=0\)}
    \LComment{no turns, pre-color all vertices}
    \ForEach{logic gate \(g\) in \(C\)}
    \State{evaluate \(g\) and color \(Œì_g\) accordingly, per \cref{th:logic-graphs}}
    \EndFor
    %\State{run \cref{alg:circval-solver} (\CircVal{} solver) to evaluate all wire values in \(C\)}
    %\ForEach{wire \(w\)}
    %\State{pre-color \(v_w\) with the boolean value of \(w\)}
    %\EndFor
    %\ForEach{logic gate \(g\)}
    %\State{pre-color all internal vertices of \(Œì_g\), per \cref{th:logic-graphs}}
    %\EndFor
    \Else
    \LComment{partition uncolored vertices by turn}
    \State{\(U‚ÇÅ‚Üê\Set{}; U‚ÇÇ‚Üê\Set{}; \dotsc; U‚Çñ‚Üê\Set{}\)}
    \ForEach{\(i‚àà\Set{1,2,\dotsc,k}\)}
    \ForEach{wire \(w‚ààI·µ¢\)}
    \State{add \(v_w\) to \(U·µ¢\)}
    \EndFor
    \EndFor
    \ForEach{remaining (unused) vertex \(v\) in \(Œì\)}
    \If{\(v\) is not pre-colored}
    \State{add \(v\) to \(U‚Çñ\)}
    \EndIf
    \EndFor
    \EndIf
    \LComment{encode parity of winning condition via \(k\) \NOT{} graphs}
    \State{\(w‚Üê\text{output wire of \(C\)}\)}
    \ForEach{\(i=1,2,\dotsc,k\)}
    \State{introduce a new vertex \(w'\)}
    \State{introduce an edge \(w'‚Üîv_{\mathbf 2}\)}
    \State{introduce an edge \(w‚Üîw'\)}
    \State{\(w‚Üêw'\)}
    \EndFor
    \State{\Return \((Œì,Œ∫,(U‚ÇÅ,\dotsc,U‚Çñ))\)}
  \end{algorithmic}
\end{algorithm}

We prove the correctness of this reduction below, thereby showing that
\(\CircSat[k]‚â§\Col[k]\).

\begin{theorem}{\(\CircSat[k]‚â§\Col[k]\)}{}

  For any \CircSat[k] instance \((C,(I‚ÇÅ,\dotsc,I‚Çñ))\), let
  \((Œì,Œ∫,(U‚ÇÅ,\dotsc,U‚Çñ))\) denote the \Col[k] instance obtained by running
  \cref{alg:circsat-to-3col} on \((C,(I‚ÇÅ,\dotsc,I‚Çñ))\); then
  \[
    (C,(I‚ÇÅ,\dotsc,I‚Çñ))‚àà\CircSat[k] ‚ü∫ (Œì,Œ∫,(U‚ÇÅ,\dotsc,U‚Çñ))‚àà\Col[k].
  \]

\end{theorem}

\begin{proof}

  By induction on \(k\).
  \begin{itemize}

    \item In the base case, \(k=0\), the \(\CircSat[0]=\CircVal\) instance has
      no inputs (all inputs are already specified as constants).  Thus the
      resulting \(\Col[0]=\ColProp\Complement\) instance has no uncolored
      vertices; \((Œì,Œ∫)\) is a totally-colored graph.  Since \(k=0\) additional
      parity-adjusting \NOT{}-graphs are appended at the output, \(Œì\) is
      exactly same as the boolean graph \(Œì_C\) of \(C\).

      By construction of the pre-coloring, \(Œ∫\) is internally consistent. Thus
      \cref{th:gc-computes-c} implies that the output color is forced, under
      properness, to be same as the output value of \(C\).  But by construction
      the output is pre-colored \ColorId0, so the coloring \(Œ∫\) is proper if
      and only if \(C\) outputs \False{} to match that pre-coloring.
      Equivalently, \(Œ∫\) is \emph{improper} if and only if \(C\) outputs \True,
      or
      \[
        (Œì,Œ∫)‚àà\ColProp\Complement ‚ü∫ C‚àà\CircVal,
      \]
      as desired.

    \item Assume \(k>1\).  We show both directions of the implication
      separately.

      \begin{ifflist}

      \item Suppose that \((C,(I·µ¢))‚àà\CircSat[k]\); we wish to show that
        \((Œì,Œ∫,(U·µ¢))‚àà\Col[k]\).

        \((C,(I‚ÇÅ,\dotsc,I‚Çñ))‚àà\CircSat[k]\) means that there exists
        \(X‚àà\TF[\Abs{I‚ÇÅ}]\) such that \(¬¨C[I‚ÇÅ‚âîX]\), with remaining inputs
        partitioned as \(I‚ÇÇ,\dotsc,I‚Çñ\), is in
        \(\Paren*{\CircSat[k-1]}\Complement\).

        Construct \(Œ¥\colon U‚ÇÅ‚Üí\Colors\) by interpreting the boolean-value
        assignment \(I‚ÇÅ‚âîX\) as an assignment of colors to \(U‚ÇÅ\):
        \[
          Œ¥(v_{w·µ¢}) =
          \begin{cases}
            \ColorId1 & x·µ¢=\True, \\
            \ColorId0 & x·µ¢=\False
          \end{cases}.
        \]
        Then, observe that the remaining \((k-1)\)-turn game instance,
        comprising \(Œì\), the augmented coloring \(Œ∫[Œ¥]\), and with uncolored
        vertices partitioned as \(U‚ÇÇ,\dotsc,U‚Çñ\), is \emph{exactly} same as that
        obtained by the reduction \cref{alg:circsat-to-3col} on
        \((¬¨C[I‚ÇÅ‚âîX],(I‚ÇÇ,\dotsc,I‚Çñ))\).  To see this, recall that:
        \begin{itemize}[nosep]
          \item In the \(k\)-turn game, \(Œì\) is formed by appending \(k\)
            \NOT-graphs to \(Œì_C\).
          \item In the \((k-1)\)-turn game, \(Œì\) is formed by appending \(k-1\)
            \NOT-graphs to \(Œì_{¬¨C}\).
        \end{itemize}
        In both instances, the original circuit \(C\) gets negated a total of
        \(k\) additional times.

        Therefore, by induction,
        \[
          \Paren*{¬¨C[I‚ÇÅ‚âîX],(I‚ÇÇ,\dotsc,I‚Çñ)}‚àà\Paren*{\CircSat[k-1]}\Complement
          ‚ü∫
          \Paren*{Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ)}‚àà\Paren*{\Col[k-1]}\Complement.
        \]
        Consequently, \(Œ¥\) is indeed a winning move for the original \(k\)-turn
        game; it \emph{certifies} that
        \[
          (Œì,Œ∫,(U‚ÇÅ,\dotsc,U‚Çñ))‚àà\Col[k],
        \]
        as desired.

      \item Suppose that \((Œì,Œ∫,(U·µ¢))‚àà\Col[k]\); we wish to show that
        \((C,(I·µ¢))‚àà\CircSat[k]\).

        \((Œì,Œ∫,(U·µ¢))‚àà\Col[k]\) means that either \(Œ∫\) is improper, or there
        exists a ``winning'' coloring \(Œ¥\colon U‚ÇÅ‚Üí\Colors\) such that
        \[
          (Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))‚àà\Paren*{\Col[k-1]}\Complement.
        \]

        By construction, \(Œ∫\) is proper, because the only pre-colored vertices
        are the special vertex \(v_{\mathbf2}‚Ü¶\ColorId2\) and the output vertex
        \(ùíê‚Ü¶\ColorId0\).  Thus it must be that a winning \(Œ¥\) exists.

        Note that if \(Œ∫[Œ¥]\) were improper, we would immediately have
        \[
          (Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))‚àà\Col[k-1]
        \]
        (the responding player automatically wins).  But by assumption, that is
        not the case: we actually have
        \[
          (Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))‚àà\Paren*{\Col[k-1]}\Complement
        \]
        (\(Œ¥\) leads to a guaranteed \emph{loss} for the responding player). 
        Thus \(Œ∫[Œ¥]\) must be proper.

        Therefore, for each vertex \(ùíä‚±º‚ààU‚ÇÅ\), we know that \(Œ∫[Œ¥]\) only assigns
        colors \ColorId0 or \ColorId1 to \(ùíä‚±º\) since by construction \(ùíä‚±º\)
        neighbors \(v_{\mathbf2}\), which is pre-colored \ColorId2.  Thus
        construct a boolean assignment
        \(X=\Paren*{x‚ÇÅ,\dotsc,x_{\Abs{I‚ÇÅ}}}‚àà\TF[\Abs{I‚ÇÅ}]\) by
        \[
          x‚±º =
          \begin{cases}
            \True & Œ¥(ùíä‚±º)=\ColorId1 \\
            \False & Œ¥(ùíä‚±º)=\ColorId0
          \end{cases}.
        \]

        As before, note that \((Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))\) is exactly the
        same \((k-1)\)-turn instance as obtained by \cref{alg:circsat-to-3col}
        on \((¬¨C[I‚ÇÅ‚âîX],(I‚ÇÇ,\dotsc,I‚Çñ))\).  Thus by induction
        \[
          (Œì,Œ∫[Œ¥],(U‚ÇÇ,\dotsc,U‚Çñ))‚àà\Paren*{\Col[k-1]}\Complement
        \]
        implies that
        \[
          (¬¨C[I‚ÇÅ‚âîX],(I‚ÇÇ,\dotsc,I‚Çñ))‚àà\Paren*{\CircSat[k-1]}\Complement,
        \]
        and therefore \(X\) certifies that
        \[
          (C,(I‚ÇÅ,\dotsc,I‚Çñ))‚àà\CircSat[k],
        \]
        as desired.  \qedhere

      \end{ifflist}

  \end{itemize}

\end{proof}

Finally, the correctness of this reduction implies the big theorem of this
chapter: \SigmaP k-completeness of \Col[k] games.

\begin{theorem}{yay!}{yayay}

  \(\Col[k]\) is \SigmaP k-hard.  Together with \cref{cor:col-in-sigma}, this
  implies that \(\Col[k]\) is \SigmaP k-complete.

\end{theorem}


%\begin{definition}{The graph 3-colorability problem (\Problem{})}{}
%
%  The \Term{graph 3-colorability problem} is stated as the following yes/no
%  question: given a graph, is it (properly) 3-colorable?
%
%\end{definition}
%
%\begin{theorem}{}{}
%  \Problem{3col} is \NP-complete.
%\end{theorem}

%\begin{proof}
%  It is straightforward to see that \(\Problem{3col}‚àà\NP\), since it is
%  solvable by polynomial-time guess-and-check: guess a color assignment for
%  each vertex, then verify that, for each edge \(e\), the two vertices joined
%  by \(e\) have distinct colors.  The ``check'' procedure takes
%  \(\O(\Abs{\Edges[G]})\) time, which is polynomial with respect to the size of
%  the graph.
%
%  To show that \(\Problem{3col}\) is \NP-hard, we show
%  \(\CircSat‚â§\Problem{3col}\) by reducing \CircSat{} to \Problem{3col}.
%  Specifically, given a circuit \(C\) with inputs \(x‚ÇÅ,\dotsc,x‚Çô\), we wish to
%  construct a corresponding graph \(G\) such that \(G\) is 3-colorable if and
%  only if \(C\) is satisfiable.
%
%  Let such a circuit \(C\) be given.  Apply the algorithm from
%  \cref{th:circuit-to-graph} to produce a graph \(G\) that computes the boolean
%  function \(C\), such that the inputs \(x‚ÇÅ,\dotsc,x‚Çô\) of \(C\) correspond
%  respectively to input vertices \(i‚ÇÅ,\dotsc,i‚Çô\), and the output of \(C\)
%  corresponds to the output vertex \(o\).
%
%  Force the output vertex of \(G\) to take on the boolean value \(\True\) by
%  ``merging'' vertices \(o\) and \(s_\True\) into one vertex, keeping all of
%  their connections to other vertices.  (Equivalently, if we wish to avoid such
%  a ``merging'' operation, we may construct \(G\) assuming \emph{a priori} that
%  \(o=s_\True\).  Yet another alternative is to create edges joining \(o\) with
%  \(s_\False\) and \(s_\Aux\), thereby forcing it to share a color with
%  \(s_\True\).)
%
%  We claim that this resulting graph \(G\) is 3-colorable if and only if \(C\)
%  is satisfiable.
%  \begin{itemize}
%    \item[(\(‚üπ\))] Suppose that \(G\) is 3-colorable.  Then let \(Œ∫\) be a
%      proper 3-coloring of \(G\).  Let \(x‚ÇÅ,\dotsc,x‚Çô\) be the respective
%      boolean values assigned by \(Œ∫\) to the input vertices \(i‚ÇÅ,\dotsc,i‚Çô\)
%      of \(G\). Since \(G\) computes \(C\)
%      (\cref{def:boolean-graph-functions}), we know that
%      \(Œ∫(o)=C(x‚ÇÅ,\dotsc,x‚Çô)\).  At the same time, we have also ensured by
%      construction that \(Œ∫(o)=\True\).  Thus \(x‚ÇÅ,\dotsc,x‚Çô\) is a satisfying
%      assignment for \(C\).  Thus \(C\) is satisfiable.
%
%    \item[(\(‚ü∏\))] Suppose that \(C\) is satisfiable.  Then let
%      \(x‚ÇÅ,\dotsc,x‚Çô\) be a satisfying assignment for \(C\).  We construct a
%      3-coloring for \(G\) as follows:
%      \begin{itemize}
%        \item Arbitrarily color the special vertices
%          \(s_\True,s_\False,s_\Aux\).  Call those colors \(\True,\False,\Aux\)
%          respectively.
%        \item For each input TODO unfinished
%      \end{itemize}
%
%
%  \end{itemize}
%
%
%\end{proof}

\section{Can we avoid pre-coloring vertices?}

\label{sec:precolor}

Yes!  For sake of brevity, we give no formalisms/proofs in this chapter;
instead, we focus only on the intuition of why un-colored graphs, despite
seeming more limited at first glance, are basically equivalent to pre-colored
graphs.  That is, the choice to work with pre-colored graphs makes virtually no
practical difference; it is only a convenient device to simplify discourse.

At the start of this chapter, we assumed a specific convention for representing
boolean values as colors: \True{} is \ColorId1 and \False{} is \ColorId0,
leaving \ColorId2 unused.  Aside from being intuitively convenient, this
convention is entirely arbitrary.  In the context of proper 3-colorings, none of
the three colors are special in any way; properness/improperness is preserved
under any permutation of colors.

Therefore, when we start with an uncolored graph, there is no association
\emph{a priori} between specific colors and boolean values.  However, an
association is \emph{induced} as soon as some vertices are colored in.  For
example, whatever color is received by the special \(v_{\mathbf 2}\) vertex
represents the ``not-a-boolean'' color.  It doesn't matter what exactly that
color is‚Äîred, yellow, green‚Äîby permuting the names of the colors, we can always
\emph{call} that color \ColorId2, without loss of generality.  Similarly, the
\AND-graphs and \OR-graphs link to a pre-colored \ColorId1 vertex.  Here, that
vertex starts out uncolored, but as soon as it becomes colored, we call that
color \ColorId1.  Finally, we call the last remaining color \ColorId0.

To ensure that these induced pre-coloring associations are consistent‚Äîe.g., that
\ColorId1 and \ColorId2 don't accidentally coincide‚Äîwe start out by constructing
a special triangle comprising vertices
\(v_{\mathbf0},v_{\mathbf1},v_{\mathbf2}\).  Because these special vertices are
joined by a triangle, they must receive all three distinct colors (under any
proper coloring).  Regardless of which specific hues the players choose to color
this triangle, we simply call the colors of this triangle by the names
\(\ColorId0,\ColorId1,\ColorId2\), respectively.

In the original construction, wherever we would have made connections to a
pre-colored vertex, we instead make connections to one of the special vertices
instead.  Finally, in \Col[k] games, we ensure that the triangle actually
functions as a \emph{pre-}coloring, by including special vertices in the first
group of vertices \(U‚ÇÅ\), so that they are the first to be colored, and
subsequent properness constraints imply that all other colorings must be
consistent with the special pre-colorings.

%\section{Set covering games}
%
%introduce exact set covering problem
%
%introduce set covering game
%
%key idea: embedding circuits in set coverings
%
%proofs of game completeness
