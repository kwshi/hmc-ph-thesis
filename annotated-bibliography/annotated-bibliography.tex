\documentclass{extarticle}

\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{lastpage}
\geometry{
  top=.25in,
  bottom=.25in,
  left=1in,
  right=1in,
  includeheadfoot,
  headsep=1em,
  headheight=1em,
}
\fancypagestyle{annotated-bibliography}{
  \fancyhf{}
  \lhead{\bfseries Math Thesis: Annotated Bibliography}
  \rhead{Kye Shi}
  \rfoot{\thepage{} / \pageref{LastPage}}
}
\pagestyle{annotated-bibliography}

\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{libertinus}
\usepackage{microtype}
\usepackage{parskip}
\renewcommand\familydefault\sfdefault

\setmonofont{Fira Code}[Scale=MatchLowercase]

\usepackage{hyperref}
\usepackage{url}

\usepackage[style=authortitle]{biblatex}
\addbibresource{bibliography.bib}

\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\newtcolorbox{annotation}{
  breakable,
  sharp corners,
  opacityframe=0,
  opacityback=0,
  boxsep=0pt,
  right=0em,
  left=2em,
  parbox=false,
}

\begin{document}

The topic of my thesis is \emph{puzzle generation}.  When we talk about
complexity problems \& algorithms, we mostly focus on \emph{solving} problems
(i.e., ``given so-and-so setup, find so-and-so satisfying some conditions'').
But what does it take to \emph{make} a good puzzle?  How hard is it to generate
a good Sudoku puzzle?  What does \emph{good} even mean?  Are there general ways
to generate arbitrary, NP-complete/NP-hard ``flavored'' puzzles?

\paragraph{Annotated bibliography}

\begin{itemize}

  \item \fullcite{language-instances}

    \begin{annotation}
      This paper introduces the simplest formal model for efficient puzzle
      generators.  A \emph{polynomial time constructor} (PTC) for a language
      \(L\) is a deterministic program that, on input \(1^n\), runs in
      polynomial-time and returns a string in \(L\) with length \(n\) iff one
      exists.  \emph{Polynomial time generators} (PTGs) is the nondeterministic
      analog of PTCs, with the additional requirement that every string in
      \(L\) of length \(n\) must be reachable.  PTCs and PTGs could be thought
      of as programs that produce solvable puzzles of given sizes (e.g., given
      \(n\), generate a solvable \(n^2 \times n^2\) Sudoku board).

      The main question explored here is: which classes of languages
      (puzzles/problems) have PTCs and PTGs?  Relevant results include:
      \begin{itemize}
        \item Every language that has a PTG is in NP.
        \item For any language \(L\) in NP, \(L\) has a PTC iff it has a PTG.
        \item Every P language has a PTG iff every NP language has a PTG.
      \end{itemize}
      Surprisingly enough, that last result indicates that we don't know
      whether every P language has a PTG.  This paper goes on to define various
      special types of PTGs (e.g., categorical, lexicographical, etc.) and
      establishes various connections between PTG-existence questions and
      polynomial-hierarchy relations.
    \end{annotation}

  \item \fullcite{test-gen-complexity}

    \begin{annotation}
      In this paper, Sanchis generalizes the notion of puzzle generators
      introduced in \textcite{language-instances}.  Define a \emph{Test
      Instance Construction Method} (TICM) with respect to some fixed problem
      \(\Pi\) as a non-deterministic, polynomial-time program that, given a
      \emph{desired} answer \(\alpha\) (along with some desired parameters on
      the input, e.g., length), attempts to return an instance/input of \(\Pi\)
      that has answer \(\alpha\) and which meets the target parameters.

      The key result from this paper is that, unless NP = co-NP, most NP-hard
      problems do \emph{not} have efficient TICMs that can generate all input
      instances (with given known answers).  This establishes theoretical upper
      bounds on how comprehensive we can reasonably expect a puzzle generator
      to be in its coverage of available/possible inputs.
    \end{annotation}

  \item \fullcite{hard-diverse-graph-tests}

    \begin{annotation}
      In this paper, Sanchis continues to tackle the question, which problems
      have efficient TICMs?  This time, she further relaxes the desired TICM
      criterion---instead of looking for TICMs that can generate \emph{all}
      matching input instances, simply look for TICMs that generate a
      representative, or \emph{diverse}, set of inputs.  For a given problem
      optimization problem \(P\) and with respect to parameters (computable
      functions on \((\text{input}, \text{solution})\) pairs) \(l_1, \dots,
      l_k\), a set \(S\) of \((\text{input}, \text{solution})\) pairs is
      \emph{diverse} if every optimal pair in \(P\) has a corresponding pair in
      \(S\) with the same parameter values.

      The parameters \(l_1, \dotsc, l_k\) capture the way in which we can
      control properties of the generated puzzle instance.  Taking Sudoku as an
      example, \(l_i\) may be used to control the size of the board, the number
      of pre-filled squares, etc.  As another example, graph-based problems
      (e.g., traveling salesman, Hamiltonian path) may set \(l_i\) to be the
      number of vertices, edges, weights, etc. in the input graph.  In this
      sense, a diverse set contains representative puzzles for each
      (attainable) property combination; a diverse \emph{generator} is one
      capable of \emph{producing} puzzles for each such combination.

      This paper takes the TICM question in a concrete and exciting direction
      by \emph{constructing} efficient, hard (technical definition that roughly
      means ``doesn't only output trivially-solvable puzzles''), and diverse
      puzzle generators for three graph problems: minimum vertex cover,
      domination number, and chromatic number.
    \end{annotation}

  \item \fullcite{stable-marriage-generation}

    \begin{annotation}
      This paper explores puzzle generation for the Stable Matching (SM)
      problem allowing for ties and incomplete preference lists.  The SM
      problem is stated as follows: given \(n\) people and \(n\) pets, and
      given a strictly-ordered preference list for each person and each pet,
      pair up people with pets so that no person and no pets simultaneously
      prefer each other to their currently-assigned partners; such a matching
      is called \emph{stable}.  The SM problem is solvable in quadratic time;
      the SMT variation, in which preference orderings are non-strict (i.e.,
      allowing ties), as well as the SMI variation, in which preferences lists
      may be incomplete (unspecified preferences are unacceptable; matchings
      may be partial), are also both solvable within quadratic time.  However,
      the \emph{SMTI} variation, in which both ties and incomplete lists are
      allowed, is NP-complete.

      This paper explores several proposed methods for generating SMTI puzzles,
      evaluating them by the criterion laid out in
      \textcite{test-gen-complexity}, and demonstrates the theoretical
      shortcomings of each approach
    \end{annotation}

  \item \fullcite{random-latin-squares-sudoku}

  \item \fullcite{strategy-solvable-sudoku}

  \item \fullcite{sudoku-education}

  \item \fullcite{conp-approximation}

\end{itemize}


\end{document}
